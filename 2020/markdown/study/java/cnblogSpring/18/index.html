<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Spring源码分析（十八）创建bean | 莫问的博客</title>
  <meta name="keywords" content=" 编程 , java , 框架 , spring ">
  <meta name="description" content="Spring源码分析（十八）创建bean | 莫问的博客">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="网址ip查询修改ip 免费HTTPS证书证书 webpack入口 Entry  出口 Output 加载器 Loaders 插件 Plugins 基础配置# 初始化 npm init # 本地局部安装webpack cnpm install webpack --save-dev # 安装webpack-dev-server (启动服务、热更新、接口代理) cnpm install webpack-">
<meta property="og:type" content="article">
<meta property="og:title" content="iview">
<meta property="og:url" content="https://c4code.gitee.io/blog/2020/markdown/study/web/web/index.html">
<meta property="og:site_name" content="莫问的博客">
<meta property="og:description" content="网址ip查询修改ip 免费HTTPS证书证书 webpack入口 Entry  出口 Output 加载器 Loaders 插件 Plugins 基础配置# 初始化 npm init # 本地局部安装webpack cnpm install webpack --save-dev # 安装webpack-dev-server (启动服务、热更新、接口代理) cnpm install webpack-">
<meta property="og:locale" content="zh">
<meta property="article:published_time" content="2020-04-20T05:52:07.107Z">
<meta property="article:modified_time" content="2020-04-20T04:46:27.353Z">
<meta property="article:author" content="莫问-廖远佩">
<meta property="article:tag" content="编程">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="js">
<meta property="article:tag" content="vue">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/blog/img/avatar.jpg">

<link href="/blog/css/style.css?v=1.0.1" rel="stylesheet">

<link href="/blog/css/hl_theme/zenbum.css?v=1.0.1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/blog/js/jquery.autocomplete.min.js?v=1.0.1" ></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js" ></script>

<script src="/blog/js/iconfont.js?v=1.0.1" ></script>

<meta name="generator" content="Hexo 4.2.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
  <input class="theme_blog_path" value="/blog">
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/blog/" class="avatar_target">
    <img class="avatar" src="/blog/img/avatar.jpg" />
</a>
<div class="author">
    <span>莫问-廖远佩</span>
</div>

<div class="icon">
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(99)</small></div></li>
    
        
            
            <li><div data-rel="杂项">杂项<small>(4)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="生活"><i class="fold iconfont icon-right"></i>生活<small>(3)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="win10">win10<small>(2)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="理财">理财<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="devops">devops<small>(3)</small></div>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
            <li><div data-rel="算法"><i class="fold iconfont icon-right"></i>算法<small>(1)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="排序算法">排序算法<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="linux">linux<small>(2)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="中间件">中间件<small>(3)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="方法论">方法论<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="框架"><i class="fold iconfont icon-right"></i>框架<small>(37)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="spring">spring<small>(34)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="mybatis">mybatis<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="SpringCloud">SpringCloud<small>(2)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="工具">工具<small>(10)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="数据库">数据库<small>(25)</small></div>
                
            </li>
            
        
    
        
            
        
    
        
            
            <li><div data-rel="思维导图">思维导图<small>(1)</small></div>
                
            </li>
            
        
    
        
            
        
    
        
            
            <li><div data-rel="前端">前端<small>(3)</small></div>
                
            </li>
            
        
    
        
            
        
    
        
            
            <li><div data-rel="java"><i class="fold iconfont icon-right"></i>java<small>(5)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="GC">GC<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="新特性">新特性<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="99">
<input type="hidden" id="yelog_site_word_count" value="169.1k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode === 13){return false;}">
        <input id="local-search-input" class="search" type="text" placeholder="Search..." />
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none" />
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a class="color3">目录</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">生活</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">技巧</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">理财</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">编程</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">devops</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">技巧,win10</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">算法</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">linux</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">中间件</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">方法论</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">杂谈</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">java</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">框架</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">spring</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">正则</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">工具</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">mybatis</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">面试</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">数据库</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">redis</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">mysql</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">读书</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">python</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">思维导图</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">git</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">ide</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">前端</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">js</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">vue</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">JVM</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">GC</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">杂项</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">jvm</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">线程</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">设计模式</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <nav id="title-list-nav">
        
        <a  class="杂项 "
           href="/blog/2020/markdown/README/"
           data-tag="目录"
           data-author="" >
            <span class="post-title" title="markdown目录">markdown目录</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:05">2020/04/20</span>-->
        </a>
        
        <a  class="生活 win10 "
           href="/blog/2020/markdown/life/windows/bat/"
           data-tag="生活,技巧"
           data-author="" >
            <span class="post-title" title="BAT">BAT</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="生活 理财 "
           href="/blog/2020/markdown/life/finance/money/"
           data-tag="生活,理财"
           data-author="" >
            <span class="post-title" title="理财入门">理财入门</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="杂项 "
           href="/blog/2020/markdown/life/windows/security/"
           data-tag="技巧"
           data-author="" >
            <span class="post-title" title="security">security</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="devops "
           href="/blog/2020/markdown/study/docker/devops/"
           data-tag="编程,devops"
           data-author="" >
            <span class="post-title" title="devops">devops</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="生活 win10 "
           href="/blog/2020/markdown/life/windows/use/"
           data-tag="技巧,win10"
           data-author="" >
            <span class="post-title" title="win10使用">win10使用</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="devops "
           href="/blog/2020/markdown/study/docker/docker/"
           data-tag="编程,devops"
           data-author="" >
            <span class="post-title" title="docker">docker</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="算法 排序算法 "
           href="/blog/2020/markdown/study/algorithm/%E5%9B%BE%E7%A4%BA%E7%AE%97%E6%B3%95/"
           data-tag="编程,算法"
           data-author="" >
            <span class="post-title" title="图示经典算法">图示经典算法</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="linux "
           href="/blog/2020/markdown/study/linux/linux/"
           data-tag="编程,linux"
           data-author="" >
            <span class="post-title" title="linux">linux</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="linux "
           href="/blog/2020/markdown/study/linux/linux_mint/"
           data-tag="编程"
           data-author="" >
            <span class="post-title" title="linux mint">linux mint</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class=""
           href="/blog/2020/markdown/study/linux/%E6%A2%AF%E5%AD%90%E6%90%AD%E5%BB%BA/"
           data-tag="linux"
           data-author="" >
            <span class="post-title" title="梯子">梯子</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="中间件 "
           href="/blog/2020/markdown/study/middleware/RocketMq/"
           data-tag="编程,中间件"
           data-author="" >
            <span class="post-title" title="rocketMQ">rocketMQ</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="方法论 "
           href="/blog/2020/markdown/study/java/README/"
           data-tag="方法论,杂谈"
           data-author="" >
            <span class="post-title" title="学习方法">学习方法</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/Spring/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring">Spring</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="工具 "
           href="/blog/2020/markdown/study/java/reg/"
           data-tag="编程,正则,工具"
           data-author="" >
            <span class="post-title" title="正则表达式">正则表达式</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="中间件 "
           href="/blog/2020/markdown/study/middleware/nginx/"
           data-tag="编程,中间件"
           data-author="" >
            <span class="post-title" title="nginx">nginx</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 mybatis "
           href="/blog/2020/markdown/study/mybatis/mybatis%E9%9D%A2%E8%AF%95/"
           data-tag="mybatis,面试"
           data-author="" >
            <span class="post-title" title="mybatis面试">mybatis面试</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/SQL%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BB/"
           data-tag="编程,数据库"
           data-author="" >
            <span class="post-title" title="SQL分类">SQL分类</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="中间件 "
           href="/blog/2020/markdown/study/mysql/redis/"
           data-tag="编程,中间件,redis"
           data-author="" >
            <span class="post-title" title="redis">redis</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/mysql%E5%9F%BA%E7%A1%80/"
           data-tag="编程,数据库"
           data-author="" >
            <span class="post-title" title="mysql基础">mysql基础</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/sql%E4%BC%98%E5%8C%96/"
           data-tag="编程,java,框架,spring,面试"
           data-author="" >
            <span class="post-title" title="面试sql优化">面试sql优化</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/%E4%BC%98%E5%8C%96demo/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="实验数据">实验数据</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/%E6%95%B0%E6%8D%AE%E5%BA%9358%E5%86%9B%E8%A7%84/"
           data-tag="编程,数据库"
           data-author="" >
            <span class="post-title" title="58同城数据库军规">58同城数据库军规</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"
           data-tag="编程,数据库"
           data-author="" >
            <span class="post-title" title="数据库系统原理">数据库系统原理</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/%E9%AB%98%E6%80%A7%E8%83%BD/"
           data-tag="编程,数据库,mysql,读书"
           data-author="" >
            <span class="post-title" title="mysql高性能(第三版)">mysql高性能(第三版)</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="devops "
           href="/blog/2020/markdown/study/other/python/"
           data-tag="编程,python"
           data-author="" >
            <span class="post-title" title="python">python</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="思维导图 "
           href="/blog/2020/markdown/study/other/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"
           data-tag="目录,编程,思维导图"
           data-author="" >
            <span class="post-title" title="思维导图目录">思维导图目录</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="工具 "
           href="/blog/2020/markdown/study/tool/ffmpeg/"
           data-tag="生活,编程,工具"
           data-author="" >
            <span class="post-title" title="FFMPEG使用">FFMPEG使用</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="工具 "
           href="/blog/2020/markdown/study/tool/git/"
           data-tag="编程,工具,git"
           data-author="" >
            <span class="post-title" title="git">git</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="工具 "
           href="/blog/2020/markdown/study/tool/ide/"
           data-tag="编程,工具,ide"
           data-author="" >
            <span class="post-title" title="ide">ide</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="工具 "
           href="/blog/2020/markdown/study/tool/mysqlcli/"
           data-tag="编程,工具,mysql"
           data-author="" >
            <span class="post-title" title="mysql workbench">mysql workbench</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="工具 "
           href="/blog/2020/markdown/study/tool/oss/"
           data-tag="编程,工具"
           data-author="" >
            <span class="post-title" title="阿里云oss">阿里云oss</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="前端 "
           href="/blog/2020/markdown/study/web/js/"
           data-tag="编程,前端,js"
           data-author="" >
            <span class="post-title" title="JS">JS</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="前端 "
           href="/blog/2020/markdown/study/web/vue/"
           data-tag="编程,前端,js,vue"
           data-author="" >
            <span class="post-title" title="vue">vue</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="前端 "
           href="/blog/2020/markdown/study/web/web/"
           data-tag="编程,前端,js,vue"
           data-author="" >
            <span class="post-title" title="iview">iview</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/02/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（二）容器基本用法">Spring源码分析（二）容器基本用法</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="java GC "
           href="/blog/2020/markdown/study/java/base/%E5%9F%BA%E6%9C%AC%E5%8A%9F-GC/"
           data-tag="编程,JVM,GC"
           data-author="" >
            <span class="post-title" title="GC基础">GC基础</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="java 新特性 "
           href="/blog/2020/markdown/study/java/base/jdk8%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag="编程"
           data-author="" >
            <span class="post-title" title="jdk8新特性">jdk8新特性</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/04/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（四）容器的基础XmlBeanFactory">Spring源码分析（四）容器的基础XmlBeanFactory</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/06/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（六）解析和注册BeanDefinitions">Spring源码分析（六）解析和注册BeanDefinitions</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/05/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="pring源码分析（五）获取Document">pring源码分析（五）获取Document</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/03/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（三）容器核心类">Spring源码分析（三）容器核心类</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/08/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（八）AbstractBeanDefinition属性">Spring源码分析（八）AbstractBeanDefinition属性</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/09/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（九）解析默认标签中的自定义标签元素">Spring源码分析（九）解析默认标签中的自定义标签元素</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/10/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（十）注册解析的BeanDefinition">Spring源码分析（十）注册解析的BeanDefinition</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/12/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（十二）FactoryBean的使用">Spring源码分析（十二）FactoryBean的使用</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/13/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（十三）缓存中获取单例bean">Spring源码分析（十三）缓存中获取单例bean</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/07/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（七）bean标签的解析及注册">Spring源码分析（七）bean标签的解析及注册</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/11/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（十一）bean的加载">Spring源码分析（十一）bean的加载</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/14/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（十四）从bean的实例中获取对象">Spring源码分析（十四）从bean的实例中获取对象</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/15/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（十五）获取单例">Spring源码分析（十五）获取单例</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/16/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（十六）准备创建bean">Spring源码分析（十六）准备创建bean</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/17/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（十七）循环依赖">Spring源码分析（十七）循环依赖</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/19/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（十九）容器的功能扩展概览">Spring源码分析（十九）容器的功能扩展概览</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/20/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（二十）准备环境">Spring源码分析（二十）准备环境</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/21/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（二十一）加载BeanFactory">Spring源码分析（二十一）加载BeanFactory</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/22/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（二十二）功能扩展">Spring源码分析（二十二）功能扩展</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/24/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（二十四）初始化非延迟加载单例">Spring源码分析（二十四）初始化非延迟加载单例</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/23/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（二十三）BeanFactory的后处理">Spring源码分析（二十三）BeanFactory的后处理</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/25/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（二十五）finishRefresh">Spring源码分析（二十五）finishRefresh</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/28/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（二十八）mvc快速体验">Spring源码分析（二十八）mvc快速体验</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/27/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（二十七）静态AOP">Spring源码分析（二十七）静态AOP</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/29/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（二十九）ContextLoaderListener">Spring源码分析（二十九）ContextLoaderListener</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/26/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（二十六）动态AOP">Spring源码分析（二十六）动态AOP</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/30/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（三十）DispatcherServlet">Spring源码分析（三十）DispatcherServlet</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/README/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码解析目录">Spring源码解析目录</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/31/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（三十一）DispatcherServlet的逻辑处理">Spring源码分析（三十一）DispatcherServlet的逻辑处理</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="工具 "
           href="/blog/2020/markdown/study/java/jvmtool/arthas/"
           data-tag="编程,java,工具"
           data-author="" >
            <span class="post-title" title="Arthas">Arthas</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/spring%E9%9D%A2%E8%AF%95/"
           data-tag="编程,java,框架,spring,面试"
           data-author="" >
            <span class="post-title" title="spring面试问题与答案集锦">spring面试问题与答案集锦</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="工具 "
           href="/blog/2020/markdown/study/java/jvmtool/jstat/"
           data-tag="编程,java,工具"
           data-author="" >
            <span class="post-title" title="jstat命令手册">jstat命令手册</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="工具 "
           href="/blog/2020/markdown/study/java/jvmtool/tool/"
           data-tag="编程,java,工具"
           data-author="" >
            <span class="post-title" title="javap">javap</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="杂项 "
           href="/blog/2020/markdown/study/java/netease/2020%E4%BD%9C%E4%B8%9A/"
           data-tag="编程,java,杂项"
           data-author="" >
            <span class="post-title" title="作业记录">作业记录</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="杂项 "
           href="/blog/2020/markdown/study/java/netease/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/"
           data-tag="编程,java,读书,jvm"
           data-author="" >
            <span class="post-title" title="深入理解虚拟机">深入理解虚拟机</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 SpringCloud "
           href="/blog/2020/markdown/study/java/springcloud/springBoot/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="SpringBoot">SpringBoot</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 SpringCloud "
           href="/blog/2020/markdown/study/java/springcloud/springCloud/"
           data-tag="编程,java,框架"
           data-author="" >
            <span class="post-title" title="SpringCloud">SpringCloud</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="java "
           href="/blog/2020/markdown/study/java/thread/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/"
           data-tag="编程,java,面试,线程"
           data-author="" >
            <span class="post-title" title="一次简单的线程池面试">一次简单的线程池面试</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="java "
           href="/blog/2020/markdown/study/java/%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="JAVA性能优化权威">JAVA性能优化权威</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="java "
           href="/blog/2020/markdown/study/java/%E4%BC%98%E5%8C%96/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
           data-tag="编程,设计模式"
           data-author="" >
            <span class="post-title" title="设计模式">设计模式</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="工具 "
           href="/blog/2020/markdown/study/java/%E5%B7%A5%E5%85%B7/maven/"
           data-tag="编程,工具"
           data-author="" >
            <span class="post-title" title="maven">maven</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/01.awk/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="AWK">AWK</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/02.%E5%91%A8%E6%9C%9F%E6%80%A7%E9%97%AE%E9%A2%98%E5%AE%9E%E9%AA%8C/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="MySQL周期性波动试验">MySQL周期性波动试验</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/03.%E5%AF%B9%E4%BA%8E%E4%B8%8D%E8%A7%84%E5%88%99%E7%9A%84%E5%BB%B6%E8%BF%9F%E7%8E%B0%E8%B1%A1%E7%9A%84%E8%A7%82%E5%AF%9F/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="对于不规则的延迟现象的观察">对于不规则的延迟现象的观察</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/04.%E5%88%97%E7%9A%84%E9%80%89%E6%8B%A9/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="选择原则">选择原则</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/05.%E5%A4%9A%E5%88%97%E7%B4%A2%E5%BC%95/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="索引的优化--生效规则">索引的优化--生效规则</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/06.%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="聚簇索引与非聚簇索引">聚簇索引与非聚簇索引</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/07.%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96/"
           data-tag="编程,数据库"
           data-author="" >
            <span class="post-title" title="索引覆盖">索引覆盖</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/08.%E7%B4%A2%E5%BC%95%E9%95%BF%E5%BA%A6/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="索引长度与区分度">索引长度与区分度</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/09.%E5%BB%B6%E8%BF%9F%E5%85%B3%E8%81%94/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="延迟关联">延迟关联</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/10.%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%8E%92%E5%BA%8F/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="索引与排序">索引与排序</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/11.%E9%87%8D%E5%A4%8D%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%86%97%E4%BD%99%E7%B4%A2%E5%BC%95/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="重复索引与冗余索引">重复索引与冗余索引</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/12.%E7%B4%A2%E5%BC%95%E7%A2%8E%E7%89%87%E4%BF%AE%E5%A4%8D/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="索引碎片与维护">索引碎片与维护</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/13.explain/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="explain分析sql效果">explain分析sql效果</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/14.%E5%AD%90%E6%9F%A5%E8%AF%A2/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="子查询">子查询</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/15.%E6%8A%80%E5%B7%A7/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="奇技淫巧">奇技淫巧</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/16.%E5%8F%98%E9%87%8F/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="变量的使用">变量的使用</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/17.%E4%BA%8B%E5%8A%A1/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="事务">事务</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/markdown/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/18.%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="读写分离">读写分离</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:07">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/01/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（一）基本介绍">Spring源码分析（一）基本介绍</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/markdown/study/java/cnblogSpring/18/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（十八）创建bean">Spring源码分析（十八）创建bean</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-20 13:52:06">2020/04/20</span>-->
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-markdown/study/java/cnblogSpring/18" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Spring源码分析（十八）创建bean</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
                <a  data-rel="框架">框架</a>/
            
                <a  data-rel="spring">spring</a>
            
        </span>
        
        
        <span class="tag">
            
            <a class="color3">编程</a>
            
            <a class="color5">java</a>
            
            <a class="color3">框架</a>
            
            <a class="color2">spring</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        <!--暂时影藏时间-->
        <!---->
        <!--创建时间:<time class="date" title='更新时间: 2020-04-20 12:46:26'>2020-04-20 13:52</time>-->
        <!---->
    </div>
    <div class="article-meta">
        
        <span>字数:10.4k</span>
        
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring源码分析（十八）创建bean"><span class="toc-text">Spring源码分析（十八）创建bean</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#目录"><span class="toc-text">目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一、创建bean的实例"><span class="toc-text">一、创建bean的实例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-autowireConstructor"><span class="toc-text">1. autowireConstructor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-instantiateBean"><span class="toc-text">2 . instantiateBean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-实例化策略"><span class="toc-text">3 . 实例化策略</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、记录创建bean的ObjectFactory"><span class="toc-text">二、记录创建bean的ObjectFactory</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、属性注入"><span class="toc-text">三、属性注入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-autowireByName"><span class="toc-text">1. autowireByName</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-autowireByType"><span class="toc-text">2. autowireByType</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-applyPropertyValues"><span class="toc-text">3. applyPropertyValues</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、初始化bean"><span class="toc-text">四、初始化bean</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-激活-Aware-方法"><span class="toc-text">1. 激活 Aware 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-处理器的应用"><span class="toc-text">2 . 处理器的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-激活自定义的-init-方法"><span class="toc-text">3. 激活自定义的 init 方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、注册-DisposableBean"><span class="toc-text">五、注册 DisposableBean</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Spring源码分析（十八）创建bean"><a href="#Spring源码分析（十八）创建bean" class="headerlink" title="Spring源码分析（十八）创建bean"></a><a href="https://www.cnblogs.com/warehouse/p/9383570.html" target="_blank" rel="noopener">Spring源码分析（十八）创建bean</a></h1><blockquote>
<p>本文结合《Spring源码深度解析》来分析Spring 5.0.6版本的源代码。若有描述错误之处，欢迎指正。</p>
</blockquote>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>一、创建bean的实例</p>
<p>\1. autowireConstructor</p>
<p>2 . instantiateBean</p>
<p>3 . 实例化策略</p>
<p>二、记录创建bean的ObjectFactory</p>
<p>三、属性注入</p>
<p>\1. autowireByName</p>
<p>\2. autowireByType</p>
<p>\3. applyPropertyValues</p>
<p>四、初始化bean</p>
<p>\1. 激活 Aware 方法</p>
<p>\2. 处理器的应用</p>
<p>\3. 激活自定义的 init 方法</p>
<p>五、注册 DisposableBean</p>
<p>介绍了循环依赖以及Spring中的循环依赖的处理方式后，我们继续<a href="./16.md">Spring源码分析（十六）准备创建bean</a>的内容。当经历过resolveBeforelnstantiation方法后，程序有两个选择，如果创建了代理或者说重写了InstantiationAwareBeanPostProcessor的postProcessBeforelnstantiation方法并在方法postProcessBeforelnstantiation中改变了 bean，则直接返回就可以了，否则需要进行常规bean的创建。而 这常规bean的创建就是在doCreateBean中完成的。</p>
<pre><code class="java">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
        throws BeanCreationException {

    // Instantiate the bean.
    BeanWrapper instanceWrapper = null;
    if (mbd.isSingleton()) {
        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
    }
    if (instanceWrapper == null) {
        // 根据指定bean使用对应的策略创建新的实例，如：工厂方法、构造函数自动注人、简单初始化
        instanceWrapper = createBeanInstance(beanName, mbd, args);
    }
    final Object bean = instanceWrapper.getWrappedInstance();
    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();
    if (beanType != NullBean.class) {
        mbd.resolvedTargetType = beanType;
    }

    // Allow post-processors to modify the merged bean definition.
    synchronized (mbd.postProcessingLock) {
        if (!mbd.postProcessed) {
            try {
                // 应用MergedBeanDefinitionPostProcessor
                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
            }
            catch (Throwable ex) {
                throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &quot;Post-processing of merged bean definition failed&quot;, ex);
            }
            mbd.postProcessed = true;
        }
    }

    // Eagerly cache singletons to be able to resolve circular references
    // even when triggered by lifecycle interfaces like BeanFactoryAware.
    // 是否需要提早曝光：单例 &amp; 允许循环依赖 &amp; 当前bean正在创建中，检测循环依赖
    boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;
            isSingletonCurrentlyInCreation(beanName));
    if (earlySingletonExposure) {
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Eagerly caching bean &#39;&quot; + beanName +
                    &quot;&#39; to allow for resolving potential circular references&quot;);
        }
        // 为避免后期循环依赖，可以在bean初始化完成前将创建实例的ObjectFactory加入工厂
        /**
         * getEarlyBeanReference(beanName, mbd, bean)方法：
         * 对bean再一次依赖引用，主要应用SmartInstantiationAwareBeanPostProcessor
         * 其中我们熟知的AOP就是在这里将advice动态织入bean中，若没有则直接返回bean，不做任何处理
         */
        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));
    }

    // Initialize the bean instance.
    Object exposedObject = bean;
    try {
        // 对bean进行填充，将各个属性值注入，其中，可能存在依赖于其他bean的属性，则会递归初始依赖bean
        populateBean(beanName, mbd, instanceWrapper);
        // 调用初始化方法，比如init-method
        exposedObject = initializeBean(beanName, exposedObject, mbd);
    }
    catch (Throwable ex) {
        if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {
            throw (BeanCreationException) ex;
        }
        else {
            throw new BeanCreationException(
                    mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);
        }
    }

    if (earlySingletonExposure) {
        Object earlySingletonReference = getSingleton(beanName, false);
        // earlySingletonReference只有在检测到有循环依赖的情况下才会不为空
        if (earlySingletonReference != null) {
            // 如果exposedObject没有在初始化方法中被改变，也就是没有被增强
            if (exposedObject == bean) {
                exposedObject = earlySingletonReference;
            }
            else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {
                String[] dependentBeans = getDependentBeans(beanName);
                Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);
                for (String dependentBean : dependentBeans) {
                    // 检测依赖
                    if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                        actualDependentBeans.add(dependentBean);
                    }
                }
                /**
                 * 因为bean创建后其所依赖的bean一定是已经创建的，actualDependentBeans不为空则表示当前bean创建后
                 * 其依赖的bean却没有全部创建完，也就是说存在循环依赖
                 */
                if (!actualDependentBeans.isEmpty()) {
                    throw new BeanCurrentlyInCreationException(beanName,
                            &quot;Bean with name &#39;&quot; + beanName + &quot;&#39; has been injected into other beans [&quot; +
                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                            &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +
                            &quot;wrapped. This means that said other beans do not use the final version of the &quot; +
                            &quot;bean. This is often the result of over-eager type matching - consider using &quot; +
                            &quot;&#39;getBeanNamesOfType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.&quot;);
                }
            }
        }
    }

    // Register bean as disposable.
    try {
        // 根据scope注册bean
        registerDisposableBeanIfNecessary(beanName, bean, mbd);
    }
    catch (BeanDefinitionValidationException ex) {
        throw new BeanCreationException(
                mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);
    }

    return exposedObject;
}</code></pre>
<p> 尽管日志与异常的内容非常重要，但是在阅读源码的时候似乎大部分人都会直接忽略掉。在此不深入探讨日志及异常的设计，我们看看整个函数的概要思路。</p>
<p>（1）如果是单例则需要首先清除缓存 。</p>
<p>（2）实例化 bean , 将 BeanDefinition 转换为 BeanWrapper 。转换是一个复杂的过程，但是我们可以尝试概括大致的功能，如下所示。</p>
<ul>
<li>如果存在工厂方法则使用工厂方法进行初始化。</li>
<li>一个类有多个构造函数，每个构造函数都有不同的参数，所以需要根据参数锁定构造函数并进行初始化。</li>
<li>如果既不存在工厂方法也不存在带有参数的构造函数，则使用默认的构造函数进行 bean 的实例化。</li>
</ul>
<p>（3）MergedBeanDefinitionPostProcessor的应用。</p>
<p>bean合并后的处理， Autowired 注解正是通过此方法实现诸如类型的预解析。</p>
<p>（4）依赖处理。</p>
<p>在 Spring 中会有循环依赖的情况，例如，当 A 中含有 B 的属性，而 B 中又含有 A 的属性时就会构成一个循环依赖，此时如果 A 和 B 都是单例，那么在 Spring 中的处理方式就是当创建 B 的时候，涉及自动注人 A 的步骤时，并不是直接去再次创建 A ，而是通过放入缓存中的ObjectFactory来创建实例，这样就解决了循环依赖的问题。</p>
<p>（5）属性填充。</p>
<p>将所有属性填充至 bean 的实例中。</p>
<p>（6）循环依赖检查。</p>
<p>之前有提到过，在 Sping 中解决循环依赖只对单例有效，而对于 prototype 的 bean , spring 没有好的解决办法，唯一要做的就是抛出异常。在这个步骤里面会检测已经加载的 bean 是否已经出现了依赖循环，并判断是否需要抛出异常。</p>
<p>（7）注册 DisposableBean 。</p>
<p>如果配置了 dcstroy-method ，这里需要注册以便一于在销毁时候调用。</p>
<p>（8）完成创建并返回。</p>
<p>可以看到上面的步骤非常的繁琐，每一步骤都使用了大量的代码来完成其功能，最复杂也是最难以理解的当属循环依赖的处理，在真正进人 doCreateBcan 前我们有必要先了解下循环依赖。</p>
<h1 id="一、创建bean的实例"><a href="#一、创建bean的实例" class="headerlink" title="一、创建bean的实例"></a>一、创建bean的实例</h1><p>当我们了解了循环依赖以后就可以深入分析创建 bean 的每个步骤了，首先我们从 createBeanlnstance 开始。</p>
<pre><code class="java">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
    // Make sure bean class is actually resolved at this point.
    // 解析class
    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);

    if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) {
        throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                &quot;Bean class isn&#39;t public, and non-public access not allowed: &quot; + beanClass.getName());
    }

    Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();
    if (instanceSupplier != null) {
        return obtainFromSupplier(instanceSupplier, beanName);
    }

    // 如果工厂方法不为空则使用工厂方法初始化策略
    if (mbd.getFactoryMethodName() != null)  {
        return instantiateUsingFactoryMethod(beanName, mbd, args);
    }

    // Shortcut when re-creating the same bean...
    boolean resolved = false;
    boolean autowireNecessary = false;
    if (args == null) {
        synchronized (mbd.constructorArgumentLock) {
            // 一个类有多个构造函数，每个构造函数都有不同的参数，所以调用前需要先根据参数锁定构造函数或对应的工厂方法
            if (mbd.resolvedConstructorOrFactoryMethod != null) {
                resolved = true;
                autowireNecessary = mbd.constructorArgumentsResolved;
            }
        }
    }
    // 如果已经解析过则使用解析好的构造函数
    if (resolved) {
        if (autowireNecessary) {
            // 构造函数自动注入
            return autowireConstructor(beanName, mbd, null, null);
        }
        else {
            // 使用默认构造函数构造
            return instantiateBean(beanName, mbd);
        }
    }

    // Need to determine the constructor...
    // 需要根据参数解析构造函数
    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
    if (ctors != null ||
            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||
            mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {
        // 构造函数自动注入
        return autowireConstructor(beanName, mbd, ctors, args);
    }

    // No special handling: simply use no-arg constructor.
    // 使用默认构造函数构造
    return instantiateBean(beanName, mbd);
}</code></pre>
<p>虽然代码中实例化的细节非常复杂，但是在 CreateBeanlntance 方法中我们还是可以清晰地看到实例化的逻辑的。</p>
<p>（1）如果在 RootBeanDefinition 中存在 factoryMethodName 属性，或者说在配置文件中配置了 factory-method，那么 Spring会尝试使用instantiateUsingFactoryMethod(beanName, mbd, args)方法根据 RootBeanDefinition 中的配置生成 bean 的实例。</p>
<p>（2）解析构造函数并进行构造函数的实例化。因为一个 bean 对应的类中可能会有多个构造函数，而每个构造函数的参数不同， Spring 在根据参数及类型去判断最终会使用哪个构造函数进行实例化。但是，判断的过程是个比较消耗性能的步骤，所以采用缓存机制，如果已经解析过则不需要重复解析而是直接从RootBeanDefinition中的属性resolvedConstructorOrFactoryMethod缓存的值去取，否则需要再次解析，并将解析的结果添加至RootBeanDefinition中的属性resolvedConstructorOrFactoryMethod中。</p>
<h2 id="1-autowireConstructor"><a href="#1-autowireConstructor" class="headerlink" title="1. autowireConstructor"></a>1. autowireConstructor</h2><p>对于实例的创建Spring中分成了两种情况，一种是通用的实例化，另一种是带有参数的实例化。带有参数的实例化过程相当复杂，因为存在这不确定性，所以在判断对应参数上做了大量工作。</p>
<pre><code class="java">public BeanWrapper autowireConstructor(final String beanName, final RootBeanDefinition mbd,
        @Nullable Constructor&lt;?&gt;[] chosenCtors, @Nullable final Object[] explicitArgs) {

    BeanWrapperImpl bw = new BeanWrapperImpl();
    this.beanFactory.initBeanWrapper(bw);

    Constructor&lt;?&gt; constructorToUse = null;
    ArgumentsHolder argsHolderToUse = null;
    Object[] argsToUse = null;

    // explicitArgs通过getBean方法传入
    // 如果getBean方法调用的时候指定方法参数，那么直接使用
    if (explicitArgs != null) {
        argsToUse = explicitArgs;
    }
    else {
        // 如果在getBean方法调用的时候没有指定则尝试从配置文件中解析
        Object[] argsToResolve = null;
        // 尝试从缓存中获取
        synchronized (mbd.constructorArgumentLock) {
            constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;
            if (constructorToUse != null &amp;&amp; mbd.constructorArgumentsResolved) {
                // Found a cached constructor...
                // 从缓存中取
                argsToUse = mbd.resolvedConstructorArguments;
                if (argsToUse == null) {
                    // 配置的构造函数参数
                    argsToResolve = mbd.preparedConstructorArguments;
                }
            }
        }
        // 如果缓存中存在
        if (argsToResolve != null) {
            // 解析参数类型，如给定方法的构造函数A(int, int)则通过此方法后就会把配置中的(&quot;1&quot;, &quot;1&quot;)转换为(1, 1)
            // 缓存中的值可能是原始值也可能是最终值
            argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve, true);
        }
    }

    // 没有被缓存
    if (constructorToUse == null) {
        // Need to resolve the constructor.
        boolean autowiring = (chosenCtors != null ||
                mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);
        ConstructorArgumentValues resolvedValues = null;

        int minNrOfArgs;
        if (explicitArgs != null) {
            minNrOfArgs = explicitArgs.length;
        }
        else {
            // 提取配置文件中的配置的构造函数参数
            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();
            // 用于承载解析后的构造函数参数的值
            resolvedValues = new ConstructorArgumentValues();
            // 能解析到的参数个数
            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);
        }

        // Take specified constructors, if any.
        Constructor&lt;?&gt;[] candidates = chosenCtors;
        if (candidates == null) {
            Class&lt;?&gt; beanClass = mbd.getBeanClass();
            try {
                candidates = (mbd.isNonPublicAccessAllowed() ?
                        beanClass.getDeclaredConstructors() : beanClass.getConstructors());
            }
            catch (Throwable ex) {
                throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &quot;Resolution of declared constructors on bean Class [&quot; + beanClass.getName() +
                        &quot;] from ClassLoader [&quot; + beanClass.getClassLoader() + &quot;] failed&quot;, ex);
            }
        }
        // 排序给定的构造函数，public构造函数优先参数数量降序、非public构造函数参数数量降序
        AutowireUtils.sortConstructors(candidates);
        int minTypeDiffWeight = Integer.MAX_VALUE;
        Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = null;
        LinkedList&lt;UnsatisfiedDependencyException&gt; causes = null;

        for (Constructor&lt;?&gt; candidate : candidates) {
            Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();

            if (constructorToUse != null &amp;&amp; argsToUse.length &gt; paramTypes.length) {
                // 如果已经找到选用的构造函数或者需要的参数个数小于当前的构造函数参数个数则终止，因为已经按照参数个数降序排列
                // Already found greedy constructor that can be satisfied -&gt;
                // do not look any further, there are only less greedy constructors left.
                break;
            }
            if (paramTypes.length &lt; minNrOfArgs) {
                // 参数个数不相等
                continue;
            }

            ArgumentsHolder argsHolder;
            if (resolvedValues != null) {
                // 有参数则根据值构造对应参数类型的参数
                try {
                    // 注释上获取参数名称
                    String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);
                    if (paramNames == null) {
                        // 获取参数名称探索器
                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();
                        if (pnd != null) {
                            // 获取指定构造函数的参数名称
                            paramNames = pnd.getParameterNames(candidate);
                        }
                    }
                    // 根据名称和数据类型创建参数持有者
                    argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,
                            getUserDeclaredConstructor(candidate), autowiring, candidates.length == 1);
                }
                catch (UnsatisfiedDependencyException ex) {
                    if (logger.isTraceEnabled()) {
                        logger.trace(&quot;Ignoring constructor [&quot; + candidate + &quot;] of bean &#39;&quot; + beanName + &quot;&#39;: &quot; + ex);
                    }
                    // Swallow and try next constructor.
                    if (causes == null) {
                        causes = new LinkedList&lt;&gt;();
                    }
                    causes.add(ex);
                    continue;
                }
            }
            else {
                // Explicit arguments given -&gt; arguments length must match exactly.
                if (paramTypes.length != explicitArgs.length) {
                    continue;
                }
                // 构造函数没有参数的情况
                argsHolder = new ArgumentsHolder(explicitArgs);
            }

            // 探测是否有不确定性的构造函数存在，例如不同构造函数的参数为父子关系
            int typeDiffWeight = (mbd.isLenientConstructorResolution() ?
                    argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));
            // Choose this constructor if it represents the closest match.
            // 如果它代表着当前最接近的匹配则选择作为构造函数
            if (typeDiffWeight &lt; minTypeDiffWeight) {
                constructorToUse = candidate;
                argsHolderToUse = argsHolder;
                argsToUse = argsHolder.arguments;
                minTypeDiffWeight = typeDiffWeight;
                ambiguousConstructors = null;
            }
            else if (constructorToUse != null &amp;&amp; typeDiffWeight == minTypeDiffWeight) {
                if (ambiguousConstructors == null) {
                    ambiguousConstructors = new LinkedHashSet&lt;&gt;();
                    ambiguousConstructors.add(constructorToUse);
                }
                ambiguousConstructors.add(candidate);
            }
        }

        if (constructorToUse == null) {
            if (causes != null) {
                UnsatisfiedDependencyException ex = causes.removeLast();
                for (Exception cause : causes) {
                    this.beanFactory.onSuppressedException(cause);
                }
                throw ex;
            }
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                    &quot;Could not resolve matching constructor &quot; +
                    &quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)&quot;);
        }
        else if (ambiguousConstructors != null &amp;&amp; !mbd.isLenientConstructorResolution()) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                    &quot;Ambiguous constructor matches found in bean &#39;&quot; + beanName + &quot;&#39; &quot; +
                    &quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot; +
                    ambiguousConstructors);
        }

        if (explicitArgs == null) {
            // 将解析的构造函数加入缓存
            argsHolderToUse.storeCache(mbd, constructorToUse);
        }
    }

    try {
        final InstantiationStrategy strategy = this.beanFactory.getInstantiationStrategy();
        Object beanInstance;

        if (System.getSecurityManager() != null) {
            final Constructor&lt;?&gt; ctorToUse = constructorToUse;
            final Object[] argumentsToUse = argsToUse;
            beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;
                    strategy.instantiate(mbd, beanName, this.beanFactory, ctorToUse, argumentsToUse),
                    this.beanFactory.getAccessControlContext());
        }
        else {
            beanInstance = strategy.instantiate(mbd, beanName, this.beanFactory, constructorToUse, argsToUse);
        }

        // 将构建的实例加入BeanWrapper中
        bw.setBeanInstance(beanInstance);
        return bw;
    }
    catch (Throwable ex) {
        throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                &quot;Bean instantiation via constructor failed&quot;, ex);
    }
}</code></pre>
<p>逻辑很复杂，函数代码量很大，不知道你是否坚持读完了整个函数并理解了整个功能呢？这里要先叶个槽，笔者觉得这个函数的写法完全不符合 Spring 的一贯风格，如果你一直跟随笔者的分析思路到这里，相信你或多或少对 SPring 的编码风格有所了解， Spring的一贯做法是将复杂的逻辑分解，分成 N 个小函数的嵌套，每一层都是对下一层逻辑的总结及概要，这样使得每一层的逻辑会变得简单容易理解。在上面的函数中，包含着很多的逻辑实现，笔者觉得至少应该将逻辑封装在不同函数中而使得在 autowireConstructor 中的逻辑清晰明了。</p>
<p>我们总览一下整个函数，其实现的功能考虑了以下几个方面。</p>
<p>（1）构造函数参数的确定。</p>
<p>1）根据explicitArgs参数判断。</p>
<p>如果传人的参数explicitArgs不为空，那么可以直接确定参数，因为 explicitArgs参数是在调用 Bean 的时候用户指定的，在 BeanFactory 类中存在这样的方法：Object getBean(String name, Object… args) throws BeansException;</p>
<p>在获取 bean 的时候，用户不但可以指定 bean 的名称还可以指定 bean 所对应类的构造函数或者工厂方法的方法参数，主要用于静态工厂方法的调用，而这里是需要给定完全匹配的参数的，所以，便可以判断，如果传人参数 explicitArgs不为空，则可以确定构造函数参数就是它。</p>
<p>2）缓存中获取。</p>
<p>除此之外，确定参数的办法如果之前已经分析过，也就是说构造函数参数已经记录在缓存中，那么便可以直接拿来使用。而且，这里要提到的是，在缓存中缓存的可能是参数的最终类型也可能是参数的初始类型，例如：构造函数参数要求的是 int 类型，但是原始的参数值可能是 String 类型的“1” ，那么即使在缓存中得到了参数，也需要经过类型转换器的过滤以确保参数类型与对应的构造函数参数类型完全对应。</p>
<p>3）配置文件获取。</p>
<p>如果不能根据传人的参数 explicitArgs确定构造函数的参数也无法在缓存中得到相关信息，那么只能开始新一轮的分析了。</p>
<p>分析从获取配置文件中配置的构造函数信息开始，经过之前的分析，我们知道， Spring配置文件中的信息经过转换都会通过 BeanDefinition 实例承载，也就是参数 mbd 中包含，那么可以通过调用 mbd.getConstructorArgumentValues()来获取配置的构造函数信息。有了配置中的信息便可以获取对应的参数值信息了，获取参数值的信息包括直接指定值，如：直接指定构造函数中某个值为原始类型 String 类型，或者是一个对其他 bean 的引用，而这一处理委托给 resolveConstruotorArgumcnts 方法，并返回能解析到的参数的个数。</p>
<p>( 2 ）构造函数的确定。</p>
<p>经过了第一步后已经确定了构造函数的参数，接下来的任务就是根据构造函数参数在所有构造函数中锁定对应的构造函数，而匹配的方法就是根据参数个数匹配，所以在匹配之前需要先对构造函数按照 public 构造函数优先参数数量降序、非 public 构造函数参数数量降序。这样可以在遍历的情况下迅速判断排在后面的构造函数参数个数是否符合条件。</p>
<p>由于在配置文件中并不是唯一限制使用参数位置索引的方式去创建，同样还支持指定参数名称进行设定参数值的情况，如＜ constructor-arg name = “hello” &gt; ，那么这种情况就需要首先确定构造函数中的参数名称。</p>
<p>获取参数名称可以有两种方式，一种是通过注解的方式直接获取，另一种就是使用 Spring 中提供的工具类 ParameterNameDiscoverer来获取。构造函数、参数名称、参数类型、参数值都确定后就可以锁定构造函数以及转换对应的参数类型了。</p>
<p>（3）根据确定的构造函数转换对应的参数类型。</p>
<p>主要是使用Spring 中提供的类型转换器或者用户提供的自定义类型转换器进行转换。</p>
<p>（4）构造函数不确定性的验证。</p>
<p>当然，有时候即使构造函数、参数名称、参数类型、参数值都确定后也不一定会直接锁定构造函数，不同构造函数的参数为父子关系，所以 Spring 在最后又做了一次验证。</p>
<p>（5）根据实例化策略以及得到的构造函数及构造函数参数实例化 Bean 。后面章节中将进行讲解。</p>
<h2 id="2-instantiateBean"><a href="#2-instantiateBean" class="headerlink" title="2 . instantiateBean"></a>2 . instantiateBean</h2><p>经历了带有参数的构造函数的实例构造，相信你会非常轻松愉快地理解不带参数的构造函数的实例化过程。</p>
<pre><code class="java">protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {
    try {
        Object beanInstance;
        final BeanFactory parent = this;
        if (System.getSecurityManager() != null) {
            beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;
                    getInstantiationStrategy().instantiate(mbd, beanName, parent),
                    getAccessControlContext());
        }
        else {
            beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
        }
        BeanWrapper bw = new BeanWrapperImpl(beanInstance);
        initBeanWrapper(bw);
        return bw;
    }
    catch (Throwable ex) {
        throw new BeanCreationException(
                mbd.getResourceDescription(), beanName, &quot;Instantiation of bean failed&quot;, ex);
    }
}</code></pre>
<p>你会发现，此方法并没有什么实质性的逻辑，带有参数的实例构造中，Spring 把精力都放在了构造函数以及参数的匹配上，所以如果没有参数的话那将是非常简单的一件事，直接调用实例化策略进行实例化就可以了。</p>
<h2 id="3-实例化策略"><a href="#3-实例化策略" class="headerlink" title="3 . 实例化策略"></a>3 . 实例化策略</h2><p>实例化过程中反复提到过实例化策略，那这又是做什么用的呢？其实，经过前面的分析，我们已经得到了足以实例化的所有相关信息，完全可以使用最简单的反射方法直接反射来构造实例对象，但是 Spring 却并没有这么做。 </p>
<p>SimpleInstantiationStrategy.java</p>
<pre><code class="java">@Override
public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {
    // Don&#39;t override the class with CGLIB if no overrides.
    // 如果有需要覆盖或者动态替换的方法则当然需要使用cglib进行动态代码，因为可以在创建代理的同时将动态方法织入类中
    // 但是如果没有需要动态改变的方法，为了方便直接反射就可以了
    if (!bd.hasMethodOverrides()) {
        Constructor&lt;?&gt; constructorToUse;
        synchronized (bd.constructorArgumentLock) {
            constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;
            if (constructorToUse == null) {
                final Class&lt;?&gt; clazz = bd.getBeanClass();
                if (clazz.isInterface()) {
                    throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);
                }
                try {
                    if (System.getSecurityManager() != null) {
                        constructorToUse = AccessController.doPrivileged(
                                (PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) clazz::getDeclaredConstructor);
                    }
                    else {
                        constructorToUse =    clazz.getDeclaredConstructor();
                    }
                    bd.resolvedConstructorOrFactoryMethod = constructorToUse;
                }
                catch (Throwable ex) {
                    throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;, ex);
                }
            }
        }
        return BeanUtils.instantiateClass(constructorToUse);
    }
    else {
        // Must generate CGLIB subclass.
        return instantiateWithMethodInjection(bd, beanName, owner);
    }
}</code></pre>
<p>CglibSubclassingInstantiationStrategy.java</p>
<pre><code class="java">public Object instantiate(@Nullable Constructor&lt;?&gt; ctor, @Nullable Object... args) {
    Class&lt;?&gt; subclass = createEnhancedSubclass(this.beanDefinition);
    Object instance;
    if (ctor == null) {
        instance = BeanUtils.instantiateClass(subclass);
    }
    else {
        try {
            Constructor&lt;?&gt; enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes());
            instance = enhancedSubclassConstructor.newInstance(args);
        }
        catch (Exception ex) {
            throw new BeanInstantiationException(this.beanDefinition.getBeanClass(),
                    &quot;Failed to invoke constructor for CGLIB enhanced subclass [&quot; + subclass.getName() + &quot;]&quot;, ex);
        }
    }
    // SPR-10785: set callbacks directly on the instance instead of in the
    // enhanced class (via the Enhancer) in order to avoid memory leaks.
    Factory factory = (Factory) instance;
    factory.setCallbacks(new Callback[] {NoOp.INSTANCE,
            new LookupOverrideMethodInterceptor(this.beanDefinition, this.owner),
            new ReplaceOverrideMethodInterceptor(this.beanDefinition, this.owner)});
    return instance;
}</code></pre>
<p>看了上面两个函数后似乎我们已经感受到了 Spring 的良苦用心以及为了能更方便地使用 Spring 而做了大量的工作。程序中，首先判断如果 bd.hasMethodOverrides为空也就是用户没有使用 replace 或者 lookup的配置方法，那么直接使用反射的方式，简单快捷，但是如果使用了这两个特性，在直接使用反射的方式创建实例就不妥了，因为需要将这两个配置提供的功能切入进去，所以就必须要使用动态代理的方式将包含两个特性所对应的逻辑的拦截增强器设置进去，这样才可以保证在调用方法的时候会被相应的拦截器增强，返回值为包含拦截器的代理实例。</p>
<h1 id="二、记录创建bean的ObjectFactory"><a href="#二、记录创建bean的ObjectFactory" class="headerlink" title="二、记录创建bean的ObjectFactory"></a>二、记录创建bean的ObjectFactory</h1><p>在doCreate函数中有这样一段代码：</p>
<pre><code class="java">boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;
        isSingletonCurrentlyInCreation(beanName));
if (earlySingletonExposure) {
    if (logger.isDebugEnabled()) {
        logger.debug(&quot;Eagerly caching bean &#39;&quot; + beanName +
                &quot;&#39; to allow for resolving potential circular references&quot;);
    }
    // 为避免后期循环依赖，可以在bean初始化完成前将创建实例的ObjectFactory加入工厂
    /**
     * getEarlyBeanReference(beanName, mbd, bean)方法：
     * 对bean再一次依赖引用，主要应用SmartInstantiationAwareBeanPostProcessor
     * 其中我们熟知的AOP就是在这里将advice动态织入bean中，若没有则直接返回bean，不做任何处理
     */
    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));
}</code></pre>
<p>这段代码不是很复杂，但是很多人不是太理解这段代码的作用，而且，这段代码仅从此函数中去理解也很难弄懂其中的含义，我们需要从全局的角度去思考 Spring 的依赖解决办法。</p>
<ul>
<li>earlySingletonExposure ：从字面的意思理解就是提早曝光的单例，我们暂不定义它的学名叫什么，我们感兴趣的是有哪些条件影响这个值。</li>
<li>mbd.isSingleton() ：没有太多可以解释的，此 RootBeanDefinition 代表的是否是单例。</li>
<li>this.allowCircularReferences ：是否允许循环依赖，很抱歉，并没有找到在配置文件中如何配置，但是在 AbstractRefreshableApplicationContext 中提供了设置函数，可以通过硬编码的方式进行设置或者可以通过自定义命名空间进行配置，其中硬编码的方式代码如下。</li>
</ul>
<p>ClassPathXmlApplicationContext bf = ClassPathXmlApplicationContext(“aspectTest.xml” ); bt.setAllowBeanDefinitionOverriding(false);</p>
<ul>
<li>isSingletonCurrentlylncreation(beanName) ：该 bean 是否在创建中。在 Spring 中，会有个专门的属性默认为 DefaultSingletonBeanRegistry的 singletonsCurrentlylnCreation 来记录 bean 的加载状态，在 bean 开始创建前会将 beanName 记录在属性中，在 bean 创建结束后会将 beanName 从属性中移除。那么我们跟随代码一路走来可是对这个属性的记录并没有多少印象，这个状态是在哪里记录的呢？不同 scope 的记录位置并不一样，我们以 singleton 为例，在 singleton 下记录属性的函数是在 DefaultSingletonBeanRegistry的 public Object getSingleton(String beanName, ObjectFactory singletonFactory)函数的 beforeSingletonCreation(beanName)和 afterSingletonCreation(beanName)中，在这两段函数中分别this.singletonCurrentlylnCreation.add(beanName)与 this.singletonCurrentlylnCreation.remove(beanName)来进行状态的记录与移除。</li>
</ul>
<p>经过以上分析我们了解变量 earl earlySingletonExposure 是否是单例、是否允许循环依赖、是否对应的 bean 正在创建的条件的综合。当这 3 个条件都满足时会执行 addSingletonFactory操作，那么加入 SingletonFactory的作用是什么呢？又是在什么时候调用呢？</p>
<p>我们还是以最简单的AB循环依赖为例，类A中含有属性类B，而类B中又会含有属性类A，那么初始化beanA的过程如下图所示：</p>
<p><img src="https://images2018.cnblogs.com/blog/963903/201807/963903-20180728235959408-380569022.jpg" alt="img"></p>
<p>上图展示了创建 beanA 的流程，图中我们看到，在创建 A 的时候首先会记录类 A 所对应的 beanName，并将beanA的创建工厂加入缓存中，而在对 A的属性填充也就是调用populate方法的时候又会再一次的对 B 进行递归创建。同样的，因为在 B 中同样存在 A 属性，因此在实例化 B 的的 populate 方法中又会再次地初始化 A ，也就是图形的最后，调用 getBean(A)。关键是在这里，有心的同学可以去找找这个代码的实现方式，我们之前已经讲过，在这个函数中并不是直接去实例化 A ，而是先去检测缓存中是否有已经创建好的对应的 bean ，或者是否已经创建好的 ObjectFactory，而此时对于A的 ObjectFactory我们早已经创建，所以便不会再去向后执行，而是直接调用 ObjectFactory去创建 A 。这里最关键的是 ObjectFactory的实现。 </p>
<pre><code class="java">/**
 * getEarlyBeanReference(beanName, mbd, bean)方法：
 * 对bean再一次依赖引用，主要应用SmartInstantiationAwareBeanPostProcessor
 * 其中我们熟知的AOP就是在这里将advice动态织入bean中，若没有则直接返回bean，不做任何处理
 */
addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</code></pre>
<p>其中getEarlyBeanReference的代码如下：</p>
<pre><code class="java">protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {
    Object exposedObject = bean;
    if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
        for (BeanPostProcessor bp : getBeanPostProcessors()) {
            if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
                SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;
                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);
            }
        }
    }
    return exposedObject;
}</code></pre>
<p>在 getEarlyBeanReference 函数中并没有太多的逻辑处理，或者说除了后处理器的调用外没有别的处理工作，根据以上分析，基本可以理清 spring 处理循环依赖的解决办法，在 B 中创建依赖 A 时通过 ObjectFactory 提供的实例化方法来中断 A 中的属性填充，使 B 中持有的 A 仅仅是刚刚初始化并没有填充任何属性的 A ，而这正初始化 A 的步骤还是在最开始创建 A 的时候进行的，但是因为 A 与 B 中的 A 所表示的属性地址是一样的，所以在 A 中创建好的属性填充自然可以通过 B 中的 A 获取，这样就解决了循环依赖的问题。</p>
<h1 id="三、属性注入"><a href="#三、属性注入" class="headerlink" title="三、属性注入"></a>三、属性注入</h1><p>在了解循环依赖的时候，我们曾经反复提到了 populateBean 这个函数，也多少了解了这个函数的主要功能就是属性填充，那么究竟是如何实现填充的呢？</p>
<pre><code class="java">protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
    if (bw == null) {
        if (mbd.hasPropertyValues()) {
            throw new BeanCreationException(
                    mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;);
        }
        else {
            // Skip property population phase for null instance.
            // 没有可填充的属性
            return;
        }
    }

    // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
    // state of the bean before properties are set. This can be used, for example,
    // to support styles of field injection.
    // 给InstantiationAwareBeanPostProcessors最后一次机会在属性设置前来改变bean
    // 如：可以用来支持属性注入的类型
    boolean continueWithPropertyPopulation = true;

    if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
        for (BeanPostProcessor bp : getBeanPostProcessors()) {
            if (bp instanceof InstantiationAwareBeanPostProcessor) {
                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
                // 返回值为是否继续填充bean
                if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
                    continueWithPropertyPopulation = false;
                    break;
                }
            }
        }
    }

    // 如果后处理器发出停止填充命令则终止后续的执行
    if (!continueWithPropertyPopulation) {
        return;
    }

    PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);

    if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||
            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
        MutablePropertyValues newPvs = new MutablePropertyValues(pvs);

        // Add property values based on autowire by name if applicable.
        // 根据名称自动注入
        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {
            autowireByName(beanName, mbd, bw, newPvs);
        }

        // Add property values based on autowire by type if applicable.
        // 根据类型自动注入
        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
            autowireByType(beanName, mbd, bw, newPvs);
        }

        pvs = newPvs;
    }

    // 后处理器已经初始化
    boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
    // 需要依赖检查
    boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);

    PropertyDescriptor[] filteredPds = null;
    if (hasInstAwareBpps) {
        if (pvs == null) {
            pvs = mbd.getPropertyValues();
        }
        for (BeanPostProcessor bp : getBeanPostProcessors()) {
            if (bp instanceof InstantiationAwareBeanPostProcessor) {
                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
                PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
                if (pvsToUse == null) {
                    if (filteredPds == null) {
                        filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
                    }
                    // 对所有需要依赖检查的属性进行后处理
                    pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
                    if (pvsToUse == null) {
                        return;
                    }
                }
                pvs = pvsToUse;
            }
        }
    }
    if (needsDepCheck) {
        // 依赖检查，对应depend-on属性，3.0已经弃用此属性
        if (filteredPds == null) {
            filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
        }
        checkDependencies(beanName, mbd, filteredPds, pvs);
    }

    if (pvs != null) {
        // 将属性应用到bean中
        applyPropertyValues(beanName, mbd, bw, pvs);
    }
}</code></pre>
<p>在 populateBean 函数中提供了这样的处理流程。</p>
<p>（1）InstantiationAwareBeanPostProcessor处理器的postProcessAfterInstantiation函数的应用，此函数可以控制程序是否继续进行属性填充。</p>
<p>（2）根据注入类型（byName/byType) ，提取依赖的 bean ，并统一存入 PropertyValues 中。</p>
<p>（3）应用InstantiationAwareBeanPostProcessor 处理器的postProcessPropertyValues方法，对属性获取完毕填充前对属性的再次处理，典型应用是 RequiredAnnotationBeanPostProccssor 类中对属性的验证。</p>
<p>（4）将所有PropertyValues中的属性填充至 BeanWrapper中。</p>
<p>在上面的步骤中有几个地方是我们比较感兴趣的，它们分别是依赖注人（autowireByName/autowireByType）以及属性填充，那么，接下来进一步分析这几个功能的实现细节。</p>
<h2 id="1-autowireByName"><a href="#1-autowireByName" class="headerlink" title="1. autowireByName"></a>1. autowireByName</h2><p>上文提到根据注人类型（byName/byType) ，提取依赖的 bean ，并统一存入PropertyValues中，那么我们首先了解下 byName 功能是如何实现的。</p>
<pre><code class="java">protected void autowireByName(
        String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {

    // 寻找bw中需要依赖注入的属性
    String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);
    for (String propertyName : propertyNames) {
        if (containsBean(propertyName)) {
            // 递归初始化相关的bean
            Object bean = getBean(propertyName);
            pvs.add(propertyName, bean);
            // 注册依赖
            registerDependentBean(propertyName, beanName);
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Added autowiring by name from bean name &#39;&quot; + beanName +
                        &quot;&#39; via property &#39;&quot; + propertyName + &quot;&#39; to bean named &#39;&quot; + propertyName + &quot;&#39;&quot;);
            }
        }
        else {
            if (logger.isTraceEnabled()) {
                logger.trace(&quot;Not autowiring property &#39;&quot; + propertyName + &quot;&#39; of bean &#39;&quot; + beanName +
                        &quot;&#39; by name: no matching bean found&quot;);
            }
        }
    }
}</code></pre>
<p>如果读者之前了解过autowire的使用方法，相信理解这个函数的功能不会太困难，无非是在传入参数pvs中找出已经加载的bean，并递归实例化，进而加入到pvs中。</p>
<h2 id="2-autowireByType"><a href="#2-autowireByType" class="headerlink" title="2. autowireByType"></a>2. autowireByType</h2><p>autowireByName与autowireByType对于我们理解与使用来说复杂程度都很相似，但是其实现功能的复杂度却完全不一样。</p>
<pre><code class="java">protected void autowireByType(
        String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {

    TypeConverter converter = getCustomTypeConverter();
    if (converter == null) {
        converter = bw;
    }

    Set&lt;String&gt; autowiredBeanNames = new LinkedHashSet&lt;&gt;(4);
    // 寻找bw中需要依赖注入的属性
    String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);
    for (String propertyName : propertyNames) {
        try {
            PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);
            // Don&#39;t try autowiring by type for type Object: never makes sense,
            // even if it technically is a unsatisfied, non-simple property.
            if (Object.class != pd.getPropertyType()) {
                // 探测指定属性的set方法
                MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);
                // Do not allow eager init for type matching in case of a prioritized post-processor.
                boolean eager = !PriorityOrdered.class.isInstance(bw.getWrappedInstance());
                DependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager);
                // 解析指定beanName的属性所匹配的值，并把解析到的属性名称存储在autowiredBeanNames中，如：
                // @Autowired private List&lt;A&gt; list; 将会找到所有匹配A类型的bean并将其注入
                Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);
                if (autowiredArgument != null) {
                    pvs.add(propertyName, autowiredArgument);
                }
                for (String autowiredBeanName : autowiredBeanNames) {
                    // 注册依赖
                    registerDependentBean(autowiredBeanName, beanName);
                    if (logger.isDebugEnabled()) {
                        logger.debug(&quot;Autowiring by type from bean name &#39;&quot; + beanName + &quot;&#39; via property &#39;&quot; +
                                propertyName + &quot;&#39; to bean named &#39;&quot; + autowiredBeanName + &quot;&#39;&quot;);
                    }
                }
                autowiredBeanNames.clear();
            }
        }
        catch (BeansException ex) {
            throw new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);
        }
    }
}</code></pre>
<p>实现根据名称自动匹配的第一步就是寻找 bw 中需要依赖注入的属性，同样对于根据类型自动匹配的实现来讲第一步也是寻找 bw 中需要依赖注入的属性，然后遍历这些属性并寻找类型匹配的 bean ，其中最复杂的就是寻找类型匹配的 bean。同时，Spri ng 中提供了对集合的类型注人的支持，如使川注解的方式：</p>
<pre><code class="java">@Autowired 
private List&lt;Test&gt; tests;</code></pre>
<p>Spring 将会把所有与 Test 匹配的类型找出来并注人到 tests 属性中，正是由于这一因素，所以在 autowireByType 函数中，新建了局部遍历 autowiredBeanNames，用于存储所有依赖的 bean ，如果只是对非集合类的属性注人来说，此属性并无用处。</p>
<p>对于寻找类型匹配的逻辑实现封装在了 resolveDependency 函数中。</p>
<pre><code class="java">@Override
@Nullable
public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,
        @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {

    descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());
    if (Optional.class == descriptor.getDependencyType()) {
        return createOptionalDependency(descriptor, requestingBeanName);
    }
    else if (ObjectFactory.class == descriptor.getDependencyType() ||
            ObjectProvider.class == descriptor.getDependencyType()) {
        // ObjectFactory类注入的特殊处理
        return new DependencyObjectProvider(descriptor, requestingBeanName);
    }
    else if (javaxInjectProviderClass == descriptor.getDependencyType()) {
        // javaxInjectProviderClass类注入的特殊处理
        return new Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);
    }
    else {
        Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(
                descriptor, requestingBeanName);
        if (result == null) {
            // 通用处理逻辑
            result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);
        }
        return result;
    }
}

@Nullable
public Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,
        @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {

    InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);
    try {
        Object shortcut = descriptor.resolveShortcut(this);
        if (shortcut != null) {
            return shortcut;
        }

        Class&lt;?&gt; type = descriptor.getDependencyType();
        // 用于支持Spring中新增的注解@Value
        Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);
        if (value != null) {
            if (value instanceof String) {
                String strVal = resolveEmbeddedValue((String) value);
                BeanDefinition bd = (beanName != null &amp;&amp; containsBean(beanName) ? getMergedBeanDefinition(beanName) : null);
                value = evaluateBeanDefinitionString(strVal, bd);
            }
            TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
            return (descriptor.getField() != null ?
                    converter.convertIfNecessary(value, type, descriptor.getField()) :
                    converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));
        }

        Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);
        if (multipleBeans != null) {
            return multipleBeans;
        }

        // 根据属性类型找到beanFactory中所有类型的匹配bean，
        // 返回值的构成为：key=匹配的beanName, value=beanName对应的实例化后的bean（通过getBean(beanName)返回）
        Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);
        if (matchingBeans.isEmpty()) {
            // 如果autowire的require属性为true而找到的匹配项却为空则只能抛出异常
            if (isRequired(descriptor)) {
                raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
            }
            return null;
        }

        String autowiredBeanName;
        Object instanceCandidate;

        if (matchingBeans.size() &gt; 1) {
            autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);
            if (autowiredBeanName == null) {
                if (isRequired(descriptor) || !indicatesMultipleBeans(type)) {
                    return descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);
                }
                else {
                    // In case of an optional Collection/Map, silently ignore a non-unique case:
                    // possibly it was meant to be an empty collection of multiple regular beans
                    // (before 4.3 in particular when we didn&#39;t even look for collection beans).
                    return null;
                }
            }
            instanceCandidate = matchingBeans.get(autowiredBeanName);
        }
        else {
            // We have exactly one match.
            // 已经可以确定只有一个匹配项
            Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();
            autowiredBeanName = entry.getKey();
            instanceCandidate = entry.getValue();
        }

        if (autowiredBeanNames != null) {
            autowiredBeanNames.add(autowiredBeanName);
        }
        if (instanceCandidate instanceof Class) {
            instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this);
        }
        Object result = instanceCandidate;
        if (result instanceof NullBean) {
            if (isRequired(descriptor)) {
                raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
            }
            result = null;
        }
        if (!ClassUtils.isAssignableValue(type, result)) {
            throw new BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass());
        }
        return result;
    }
    finally {
        ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);
    }
}</code></pre>
<p>寻找类型的匹配执行顺序时，首先尝试使用解析器进行解析，如果解析器没有成功解析，那么可能是使用默认的解析器没有做任何处理，或者是使用了自定义的解析器，但是对于集合等类型来说并不在解析范围之内，所以再次对不同类型进行不同情况的处理，虽说对于不同类型处理方式不一致，但是大致的思路还是很相似的，所以函数中只对数组类型进行了详细地注释。</p>
<h2 id="3-applyPropertyValues"><a href="#3-applyPropertyValues" class="headerlink" title="3. applyPropertyValues"></a>3. applyPropertyValues</h2><p>程序运行到这里，已经完成了对所有注人属性的获取，但是获取的属性是以 PropertyValues形式存在的，还并没有应用到已经实例化的 bean 中，这一工作是在applyPropertyValues中。</p>
<pre><code class="java">protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) {
    if (pvs.isEmpty()) {
        return;
    }

    if (System.getSecurityManager() != null &amp;&amp; bw instanceof BeanWrapperImpl) {
        ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());
    }

    MutablePropertyValues mpvs = null;
    List&lt;PropertyValue&gt; original;

    if (pvs instanceof MutablePropertyValues) {
        mpvs = (MutablePropertyValues) pvs;
        // 如果mpvs中的值已经被转换为对应的类型，那么可以直接设置到beanWrapper中
        if (mpvs.isConverted()) {
            // Shortcut: use the pre-converted values as-is.
            try {
                bw.setPropertyValues(mpvs);
                return;
            }
            catch (BeansException ex) {
                throw new BeanCreationException(
                        mbd.getResourceDescription(), beanName, &quot;Error setting property values&quot;, ex);
            }
        }
        original = mpvs.getPropertyValueList();
    }
    else {
        // 如果pvs并不是使用MutablePropertyValues封装的类型，那么直接使用原始的属性获取方法
        original = Arrays.asList(pvs.getPropertyValues());
    }

    TypeConverter converter = getCustomTypeConverter();
    if (converter == null) {
        converter = bw;
    }
    // 获取对应的解析器
    BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter);

    // Create a deep copy, resolving any references for values.
    List&lt;PropertyValue&gt; deepCopy = new ArrayList&lt;&gt;(original.size());
    boolean resolveNecessary = false;
    // 遍历属性，将属性转换为对应类的对应属性的类型
    for (PropertyValue pv : original) {
        if (pv.isConverted()) {
            deepCopy.add(pv);
        }
        else {
            String propertyName = pv.getName();
            Object originalValue = pv.getValue();
            Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);
            Object convertedValue = resolvedValue;
            boolean convertible = bw.isWritableProperty(propertyName) &amp;&amp;
                    !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);
            if (convertible) {
                convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);
            }
            // Possibly store converted value in merged bean definition,
            // in order to avoid re-conversion for every created bean instance.
            if (resolvedValue == originalValue) {
                if (convertible) {
                    pv.setConvertedValue(convertedValue);
                }
                deepCopy.add(pv);
            }
            else if (convertible &amp;&amp; originalValue instanceof TypedStringValue &amp;&amp;
                    !((TypedStringValue) originalValue).isDynamic() &amp;&amp;
                    !(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) {
                pv.setConvertedValue(convertedValue);
                deepCopy.add(pv);
            }
            else {
                resolveNecessary = true;
                deepCopy.add(new PropertyValue(pv, convertedValue));
            }
        }
    }
    if (mpvs != null &amp;&amp; !resolveNecessary) {
        mpvs.setConverted();
    }

    // Set our (possibly massaged) deep copy.
    try {
        bw.setPropertyValues(new MutablePropertyValues(deepCopy));
    }
    catch (BeansException ex) {
        throw new BeanCreationException(
                mbd.getResourceDescription(), beanName, &quot;Error setting property values&quot;, ex);
    }
}</code></pre>
<h1 id="四、初始化bean"><a href="#四、初始化bean" class="headerlink" title="四、初始化bean"></a>四、初始化bean</h1><p>大家应该记得在 bean 配置时 bean 中有一个 init-method 的属性，这个属性的作用是在 bean 实例化前调用 init-method 指定的方法来根据用户业务进行相应的实例化。我们现在就已经进入这个方法了，首先看一下这个方法的执行位置， Spring 中程序已经执行过 bean 的实例化，并且进行了属性的填充，而就在这时将会调用用户设定的初始化方法。</p>
<pre><code class="java">protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {
    if (System.getSecurityManager() != null) {
        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
            invokeAwareMethods(beanName, bean);
            return null;
        }, getAccessControlContext());
    }
    else {
        // 对特殊bean处理：Aware、BeanClassLoaderAware、BeanFactoryAware
        invokeAwareMethods(beanName, bean);
    }

    Object wrappedBean = bean;
    if (mbd == null || !mbd.isSynthetic()) {
        // 应用后处理器
        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
    }

    try {
        // 激活用户自定义的init方法
        invokeInitMethods(beanName, wrappedBean, mbd);
    }
    catch (Throwable ex) {
        throw new BeanCreationException(
                (mbd != null ? mbd.getResourceDescription() : null),
                beanName, &quot;Invocation of init method failed&quot;, ex);
    }
    if (mbd == null || !mbd.isSynthetic()) {
        // 后处理器应用
        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
    }

    return wrappedBean;
}</code></pre>
<p>虽然说此函数的主要日的是进行客户设定的初始化方法的调用，但是除此之外还有些其他必要的工作。</p>
<h2 id="1-激活-Aware-方法"><a href="#1-激活-Aware-方法" class="headerlink" title="1. 激活 Aware 方法"></a>1. 激活 Aware 方法</h2><p>在分析其原理之前，我们先了解一下 Aware 的使用。 Spring 中提供一些 Aware 相关接口，比如BeanFactoryAware、 ApplicationContextWware 、ResourceLoaderAware 、ServletContextWware 等，实现这些Aware 接口的 bean 在被初始之后，可以取得一些相对应的资源，例如实现BeanFactoryAware的bean在初始后， Spring 容器将会注入BeanFactory的实例，而实现ApplicationContextWware的 bean，在 bean 被初始后，将会被注入 ApplicationContext 的实例等。我们首先通过示例方法来了解一下 Aware 的使用。</p>
<p>（1）定义普通 bean 。</p>
<pre><code class="java">public class Hello {

    public void say() {
        System.out.println(&quot;hello&quot;);
    }
}</code></pre>
<p>（2）定义BeanFactoryAware类型的bean。</p>
<pre><code class="java">public class HelloBeanFactory implements BeanFactoryAware {

    private BeanFactory beanFactory;

    // 声明bean的时候Spring会自动注入BeanFactory
    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        this.beanFactory = beanFactory;
    }

    public void testAware() {
        // 通过hello这个bean id从beanFactory获取实例
        Hello hello = (Hello) beanFactory.getBean(&quot;hello&quot;);
        hello.say();
    }
}</code></pre>
<p>（3）使用main方法测试。</p>
<pre><code class="java">public static void main(String[] args) {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    HelloBeanFactory factory = (HelloBeanFactory) context.getBean(&quot;factory&quot;);
    factory.testAware();
}</code></pre>
<p>测试类运行，控制台输出：</p>
<pre><code class="bash">hello</code></pre>
<p>按照上面的方法我们可以获取到Spring中BeanFactory，并且可以根据 BeanFactory获取所有 bean，以及进行相关设置。当然还有其他 Aware 的使用方法都大同小异，看一下Spring 的实现方式，相信读者便会使用了。</p>
<pre><code class="java">private void invokeAwareMethods(final String beanName, final Object bean) {
    if (bean instanceof Aware) {
        if (bean instanceof BeanNameAware) {
            ((BeanNameAware) bean).setBeanName(beanName);
        }
        if (bean instanceof BeanClassLoaderAware) {
            ClassLoader bcl = getBeanClassLoader();
            if (bcl != null) {
                ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);
            }
        }
        if (bean instanceof BeanFactoryAware) {
            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);
        }
    }
}</code></pre>
<p>代码简单得已经没有什么好说的了。读者可以自己尝试使用别的 Aware，都比较简单。</p>
<h2 id="2-处理器的应用"><a href="#2-处理器的应用" class="headerlink" title="2 . 处理器的应用"></a>2 . 处理器的应用</h2><p>BeanPostProcessor 相信大家都不陌生，这是 Spring 中开放式架构中一个必不可少的亮点，给用户充足的权限去更改或者扩展 Spring ，而除了 BeanPostProcessor 外还有很多其他的 PostProcessor，当然大部分都是以此为基础，继承自BeanPostProcessor。 BeanPostProcessor的使用位置就是这里，在调用客户自定义初始化方法前以及调用自定义初始化方法后分别会调用 BeanPostProcessor 的 postProcessBeforelnitialization 和postProcessAfterlnitialization 方法，使用户可以根据自己的业务需求进行相应的处理。</p>
<pre><code class="java">@Override
public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)
        throws BeansException {

    Object result = existingBean;
    for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
        Object current = beanProcessor.postProcessBeforeInitialization(result, beanName);
        if (current == null) {
            return result;
        }
        result = current;
    }
    return result;
}

@Override
public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
        throws BeansException {

    Object result = existingBean;
    for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
        Object current = beanProcessor.postProcessAfterInitialization(result, beanName);
        if (current == null) {
            return result;
        }
        result = current;
    }
    return result;
}</code></pre>
<h2 id="3-激活自定义的-init-方法"><a href="#3-激活自定义的-init-方法" class="headerlink" title="3. 激活自定义的 init 方法"></a>3. 激活自定义的 init 方法</h2><p>客户定制的初始化方法除了我们熟知的使用配置 init-method 外，还有使自定义的 bean 实现InitializingBean接口，并在afterPropertiesSet中实现自己的初始化业务逻辑。</p>
<p>init-method 与afterPropertiesSet都是在初始化 bean 时执行，执行顺序是 afterPropertiesSet先执行，而 init-method 后执行。</p>
<p>在invokeInitMethods方法中就实现了这两个步骤的初始化方法调用。</p>
<pre><code class="java">protected void invokeInitMethods(String beanName, final Object bean, @Nullable RootBeanDefinition mbd)
        throws Throwable {

    // 首先会检查是否是InitializingBean，如果是，需要调用afterPropertiesSet方法
    boolean isInitializingBean = (bean instanceof InitializingBean);
    if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) {
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Invoking afterPropertiesSet() on bean with name &#39;&quot; + beanName + &quot;&#39;&quot;);
        }
        if (System.getSecurityManager() != null) {
            try {
                AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; {
                    ((InitializingBean) bean).afterPropertiesSet();
                    return null;
                }, getAccessControlContext());
            }
            catch (PrivilegedActionException pae) {
                throw pae.getException();
            }
        }
        else {
            // 属性初始化后的处理
            ((InitializingBean) bean).afterPropertiesSet();
        }
    }

    if (mbd != null &amp;&amp; bean.getClass() != NullBean.class) {
        String initMethodName = mbd.getInitMethodName();
        if (StringUtils.hasLength(initMethodName) &amp;&amp;
                !(isInitializingBean &amp;&amp; &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp;
                !mbd.isExternallyManagedInitMethod(initMethodName)) {
            // 调用自定义初始化方法
            invokeCustomInitMethod(beanName, bean, mbd);
        }
    }
}</code></pre>
<h1 id="五、注册-DisposableBean"><a href="#五、注册-DisposableBean" class="headerlink" title="五、注册 DisposableBean"></a>五、注册 DisposableBean</h1><p>Spring 中不但提供了对于初始化方法的扩展入口，同样也提供了销毁方法的扩展入口，对于销毁方法的扩展，除了我们熟知的配置属性 destroy-method 方法外，用户还叮以注册后处理器DestructionAwareBeanPostProcessor来统一处理 bean 的销毁方法，代码如下：</p>
<pre><code class="java">protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) {
    AccessControlContext acc = (System.getSecurityManager() != null ? getAccessControlContext() : null);
    if (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd)) {
        if (mbd.isSingleton()) {
            // Register a DisposableBean implementation that performs all destruction
            // work for the given bean: DestructionAwareBeanPostProcessors,
            // DisposableBean interface, custom destroy method.
            // 单例模式下注册需要销毁的bean，此方法中会处理实现DisposableBean的bean，
            // 并且对所有bean使用DestructionAwareBeanPostProcessor处理
            registerDisposableBean(beanName,
                    new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
        }
        else {
            // A bean with a custom scope...
            // 自定义scope的处理
            Scope scope = this.scopes.get(mbd.getScope());
            if (scope == null) {
                throw new IllegalStateException(&quot;No Scope registered for scope name &#39;&quot; + mbd.getScope() + &quot;&#39;&quot;);
            }
            scope.registerDestructionCallback(beanName,
                    new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
        }
    }
}</code></pre>

      
       
    </div>
</article>



<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>Spring源码分析（十八）创建bean</p>
    <p><span class="copy-title">文章字数:</span><span class="post-count">10.4k</span></p>
    <p><span class="copy-title">本文作者:</span><a  title="莫问-廖远佩">莫问-廖远佩</a></p>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> 内容非商用，仅作为学习记录之用若有侵权请联系：liaoyuanpei@foxmail.com。
    </p>
</div>








    </div>
    <div class="copyright">
        <p class="footer-entry">©2020 莫问-廖远佩</p>
<p class="footer-entry">
    本博客通过 <a href="https://hexo.io/" target="_blank">Hexo</a> 生成,主题为<a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a>
</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" ></a>

    </div>
</div>
<div class="acParent"></div>

</body>
<script src="/blog/js/jquery.pjax.js?v=1.0.1" ></script>

<script src="/blog/js/script.js?v=1.0.1" ></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#目录','#生活','#技巧','#理财','#编程','#devops','#技巧,win10','#算法','#linux','#中间件','#方法论','#杂谈','#java','#框架','#spring','#正则','#工具','#mybatis','#面试','#数据库','#redis','#mysql','#读书','#python','#思维导图','#git','#ide','#前端','#js','#vue','#JVM','#GC','#杂项','#jvm','#线程','#设计模式',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0px;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
        .nav .hide-list.fullscreen {
            left: 492px
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("/blog/blog_bg.png");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
    .post .pjax article :not(pre) > code {
        color: #24292e;
        font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
        background-color: rgba(27,31,35,.05);
        border-radius: 3px;
        font-size: 85%;
        margin: 0;
        padding: .2em .4em;
    }
    
</style>







</html>

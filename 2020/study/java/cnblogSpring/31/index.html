<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Spring源码分析（31）DispatcherServlet的逻辑处理 | 莫问的博客</title>
  <meta name="keywords" content=" 编程 , java , 框架 , spring ">
  <meta name="description" content="Spring源码分析（31）DispatcherServlet的逻辑处理 | 莫问的博客">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="网址ip查询修改ip 免费HTTPS证书证书 webpack入口 Entry  出口 Output 加载器 Loaders 插件 Plugins 基础配置# 初始化 npm init # 本地局部安装webpack cnpm install webpack --save-dev # 安装webpack-dev-server (启动服务、热更新、接口代理) cnpm install webpack-">
<meta property="og:type" content="article">
<meta property="og:title" content="iview">
<meta property="og:url" content="http://blog.jiyijy.com/2020/study/web/web/index.html">
<meta property="og:site_name" content="莫问的博客">
<meta property="og:description" content="网址ip查询修改ip 免费HTTPS证书证书 webpack入口 Entry  出口 Output 加载器 Loaders 插件 Plugins 基础配置# 初始化 npm init # 本地局部安装webpack cnpm install webpack --save-dev # 安装webpack-dev-server (启动服务、热更新、接口代理) cnpm install webpack-">
<meta property="og:locale" content="zh">
<meta property="article:published_time" content="2020-04-21T07:16:48.993Z">
<meta property="article:modified_time" content="2020-04-21T04:14:56.202Z">
<meta property="article:author" content="莫问-廖远佩">
<meta property="article:tag" content="编程">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="js">
<meta property="article:tag" content="vue">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/blog/img/avatar.jpg">

<link href="/blog/css/style.css?v=1.0.1" rel="stylesheet">

<link href="/blog/css/hl_theme/zenbum.css?v=1.0.1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/blog/js/jquery.autocomplete.min.js?v=1.0.1" ></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js" ></script>

<script src="/blog/js/iconfont.js?v=1.0.1" ></script>

<meta name="generator" content="Hexo 4.2.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
  <input class="theme_blog_path" value="/blog">
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/blog/" class="avatar_target">
    <img class="avatar" src="/blog/img/avatar.jpg" />
</a>
<div class="author">
    <span>莫问-廖远佩</span>
</div>

<div class="icon">
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(97)</small></div></li>
    
        
            
            <li><div data-rel="生活"><i class="fold iconfont icon-right"></i>生活<small>(4)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="理财">理财<small>(2)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="win10">win10<small>(2)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="杂项">杂项<small>(3)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="devops"><i class="fold iconfont icon-right"></i>devops<small>(3)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="docker">docker<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="jenkins">jenkins<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="python">python<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
            <li><div data-rel="框架"><i class="fold iconfont icon-right"></i>框架<small>(36)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="spring">spring<small>(33)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="mybatis">mybatis<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="SpringCloud">SpringCloud<small>(2)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
        
    
        
            
            <li><div data-rel="linux">linux<small>(3)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="算法"><i class="fold iconfont icon-right"></i>算法<small>(1)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="排序算法">排序算法<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="工具">工具<small>(7)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="中间件"><i class="fold iconfont icon-right"></i>中间件<small>(3)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="redis">redis<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="数据库"><i class="fold iconfont icon-right"></i>数据库<small>(25)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="基础">基础<small>(2)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="面试">面试<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="进阶">进阶<small>(17)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="规范">规范<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="读书">读书<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="进阶a">进阶a<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
            <li><div data-rel="思维导图">思维导图<small>(1)</small></div>
                
            </li>
            
        
    
        
            
        
    
        
            
            <li><div data-rel="前端">前端<small>(3)</small></div>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
            <li><div data-rel="java"><i class="fold iconfont icon-right"></i>java<small>(8)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="新特性">新特性<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="GC">GC<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="工具">工具<small>(3)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="阅读">阅读<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="about  site_url"  href="/blog/">关于</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="97">
<input type="hidden" id="yelog_site_word_count" value="174.5k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode === 13){return false;}">
        <input id="local-search-input" class="search" type="text" placeholder="Search..." />
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none" />
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a class="color3">生活</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">技巧</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">工具</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">编程</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">devops</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">docker</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">理财</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">方法论</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">win10</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">java</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">框架</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">spring</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">linux</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">算法</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">正则</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">登天梯</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">中间件</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">mybatis</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">面试</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">数据库</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">mysql</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">redis</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">python</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">读书</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">思维导图</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">目录</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">git</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">ide</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">程序</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">前端</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">js</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">vue</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">jvm</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">GC</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">杂项</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">线程</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">设计模式</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <nav id="title-list-nav">
        
        <a id="top" class="工具 "
           href="/blog/2020/study/tool/%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"
           data-tag="生活,工具,程序"
           data-author="" >
            <span class="post-title" title="工具推荐">工具推荐</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="生活 win10 "
           href="/blog/2020/life/windows/bat/"
           data-tag="生活,技巧"
           data-author="" >
            <span class="post-title" title="BAT">BAT</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="杂项 "
           href="/blog/2020/life/windows/security/"
           data-tag="技巧,工具"
           data-author="" >
            <span class="post-title" title="security">security</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="devops docker "
           href="/blog/2020/study/docker/docker/"
           data-tag="编程,devops,docker"
           data-author="" >
            <span class="post-title" title="docker">docker</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="生活 理财 "
           href="/blog/2020/life/finance/%E7%90%86%E8%B4%A2%E6%84%8F%E8%AF%86/"
           data-tag="生活,理财,方法论"
           data-author="" >
            <span class="post-title" title="理财意识觉醒">理财意识觉醒</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="生活 win10 "
           href="/blog/2020/life/windows/use/"
           data-tag="技巧,win10"
           data-author="" >
            <span class="post-title" title="win10使用">win10使用</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="devops jenkins "
           href="/blog/2020/study/docker/devops/"
           data-tag="编程,devops,docker"
           data-author="" >
            <span class="post-title" title="jenkins">jenkins</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/Spring/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="0.Spring介绍">0.Spring介绍</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="生活 理财 "
           href="/blog/2020/life/finance/money/"
           data-tag="生活,理财"
           data-author="" >
            <span class="post-title" title="理财入门">理财入门</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="linux "
           href="/blog/2020/study/linux/linux/"
           data-tag="编程,linux"
           data-author="" >
            <span class="post-title" title="linux">linux</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="算法 排序算法 "
           href="/blog/2020/study/algorithm/%E5%9B%BE%E7%A4%BA%E7%AE%97%E6%B3%95/"
           data-tag="编程,算法"
           data-author="" >
            <span class="post-title" title="图示经典算法">图示经典算法</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="工具 "
           href="/blog/2020/study/java/reg/"
           data-tag="工具,编程,正则"
           data-author="" >
            <span class="post-title" title="正则表达式">正则表达式</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="linux "
           href="/blog/2020/study/linux/linux_mint/"
           data-tag="编程"
           data-author="" >
            <span class="post-title" title="linux mint">linux mint</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="linux "
           href="/blog/2020/study/linux/%E6%A2%AF%E5%AD%90%E6%90%AD%E5%BB%BA/"
           data-tag="linux,登天梯"
           data-author="" >
            <span class="post-title" title="梯子">梯子</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="中间件 "
           href="/blog/2020/study/middleware/RocketMq/"
           data-tag="编程,中间件"
           data-author="" >
            <span class="post-title" title="RocketMQ">RocketMQ</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="中间件 "
           href="/blog/2020/study/middleware/nginx/"
           data-tag="编程,中间件"
           data-author="" >
            <span class="post-title" title="Nginx">Nginx</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 mybatis "
           href="/blog/2020/study/mybatis/mybatis%E9%9D%A2%E8%AF%95/"
           data-tag="mybatis,面试"
           data-author="" >
            <span class="post-title" title="mybatis面试">mybatis面试</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 基础 "
           href="/blog/2020/study/mysql/SQL%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BB/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="SQL分类">SQL分类</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="中间件 redis "
           href="/blog/2020/study/mysql/redis/"
           data-tag="编程,中间件,redis"
           data-author="" >
            <span class="post-title" title="redis">redis</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 面试 "
           href="/blog/2020/study/mysql/sql%E4%BC%98%E5%8C%96/"
           data-tag="编程,java,框架,面试,mysql"
           data-author="" >
            <span class="post-title" title="面试sql优化">面试sql优化</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 基础 "
           href="/blog/2020/study/mysql/mysql%E5%9F%BA%E7%A1%80/"
           data-tag="编程,数据库"
           data-author="" >
            <span class="post-title" title="mysql基础">mysql基础</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 进阶 "
           href="/blog/2020/study/mysql/%E4%BC%98%E5%8C%96demo/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="实验数据">实验数据</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 规范 "
           href="/blog/2020/study/mysql/%E6%95%B0%E6%8D%AE%E5%BA%9358%E5%86%9B%E8%A7%84/"
           data-tag="编程,数据库"
           data-author="" >
            <span class="post-title" title="58同城数据库军规">58同城数据库军规</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 进阶 "
           href="/blog/2020/study/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"
           data-tag="编程,数据库"
           data-author="" >
            <span class="post-title" title="数据库系统原理">数据库系统原理</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="devops python "
           href="/blog/2020/study/other/python/"
           data-tag="编程,python"
           data-author="" >
            <span class="post-title" title="python">python</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 读书 "
           href="/blog/2020/study/mysql/%E9%AB%98%E6%80%A7%E8%83%BD/"
           data-tag="编程,数据库,mysql,读书"
           data-author="" >
            <span class="post-title" title="mysql高性能(第三版)">mysql高性能(第三版)</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="思维导图 "
           href="/blog/2020/study/other/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"
           data-tag="编程,思维导图,目录"
           data-author="" >
            <span class="post-title" title="思维导图目录">思维导图目录</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="工具 "
           href="/blog/2020/study/tool/ffmpeg/"
           data-tag="生活,工具,编程"
           data-author="" >
            <span class="post-title" title="ffmpeg使用">ffmpeg使用</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="工具 "
           href="/blog/2020/study/tool/git/"
           data-tag="工具,编程,git"
           data-author="" >
            <span class="post-title" title="git">git</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="工具 "
           href="/blog/2020/study/tool/mysqlcli/"
           data-tag="工具,编程,mysql"
           data-author="" >
            <span class="post-title" title="mysql client">mysql client</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="工具 "
           href="/blog/2020/study/tool/ide/"
           data-tag="工具,编程,ide"
           data-author="" >
            <span class="post-title" title="ide">ide</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="前端 "
           href="/blog/2020/study/web/js/"
           data-tag="编程,前端,js"
           data-author="" >
            <span class="post-title" title="JS">JS</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="前端 "
           href="/blog/2020/study/web/vue/"
           data-tag="编程,前端,js,vue"
           data-author="" >
            <span class="post-title" title="vue">vue</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="前端 "
           href="/blog/2020/study/web/web/"
           data-tag="编程,前端,js,vue"
           data-author="" >
            <span class="post-title" title="iview">iview</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="java 新特性 "
           href="/blog/2020/study/java/base/jdk8%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag="编程"
           data-author="" >
            <span class="post-title" title="jdk8新特性">jdk8新特性</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/01/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（01）基本介绍">Spring源码分析（01）基本介绍</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="java GC "
           href="/blog/2020/study/java/base/%E5%9F%BA%E6%9C%AC%E5%8A%9F-GC/"
           data-tag="编程,jvm,GC"
           data-author="" >
            <span class="post-title" title="GC基础">GC基础</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/02/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（02）容器基本用法">Spring源码分析（02）容器基本用法</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/03/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（03）容器核心类">Spring源码分析（03）容器核心类</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/04/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（04）容器的基础XmlBeanFactory">Spring源码分析（04）容器的基础XmlBeanFactory</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/06/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（06）解析和注册BeanDefinitions">Spring源码分析（06）解析和注册BeanDefinitions</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/08/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（08）AbstractBeanDefinition属性">Spring源码分析（08）AbstractBeanDefinition属性</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/05/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（05）获取Document">Spring源码分析（05）获取Document</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/09/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（09）解析默认标签中的自定义标签元素">Spring源码分析（09）解析默认标签中的自定义标签元素</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/12/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（12）FactoryBean的使用">Spring源码分析（12）FactoryBean的使用</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/13/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（13）缓存中获取单例bean">Spring源码分析（13）缓存中获取单例bean</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/10/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（10）注册解析的BeanDefinition">Spring源码分析（10）注册解析的BeanDefinition</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/14/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（14）从bean的实例中获取对象">Spring源码分析（14）从bean的实例中获取对象</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/17/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（17）循环依赖">Spring源码分析（17）循环依赖</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/11/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（11）bean的加载">Spring源码分析（11）bean的加载</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/15/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（15）获取单例">Spring源码分析（15）获取单例</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/19/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（19）容器的功能扩展概览">Spring源码分析（19）容器的功能扩展概览</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/20/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（20）准备环境">Spring源码分析（20）准备环境</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/21/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（21）加载BeanFactory">Spring源码分析（21）加载BeanFactory</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/22/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（22）功能扩展">Spring源码分析（22）功能扩展</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/24/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（24）初始化非延迟加载单例">Spring源码分析（24）初始化非延迟加载单例</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/25/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（25）finishRefresh">Spring源码分析（25）finishRefresh</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/23/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（23）BeanFactory的后处理">Spring源码分析（23）BeanFactory的后处理</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/28/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（28）mvc快速体验">Spring源码分析（28）mvc快速体验</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/27/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（27）静态AOP">Spring源码分析（27）静态AOP</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/29/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（29）ContextLoaderListener">Spring源码分析（29）ContextLoaderListener</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/26/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（26）动态AOP">Spring源码分析（26）动态AOP</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="java 工具 "
           href="/blog/2020/study/java/jvmtool/arthas/"
           data-tag="工具,编程,java"
           data-author="" >
            <span class="post-title" title="Arthas">Arthas</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/spring%E9%9D%A2%E8%AF%95/"
           data-tag="编程,java,框架,spring,面试"
           data-author="" >
            <span class="post-title" title="spring面试问题与答案集锦">spring面试问题与答案集锦</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/30/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（30）DispatcherServlet">Spring源码分析（30）DispatcherServlet</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="java 工具 "
           href="/blog/2020/study/java/jvmtool/jstat/"
           data-tag="工具,编程,java"
           data-author="" >
            <span class="post-title" title="jstat命令手册">jstat命令手册</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="java 工具 "
           href="/blog/2020/study/java/jvmtool/tool/"
           data-tag="工具,编程,java"
           data-author="" >
            <span class="post-title" title="javap">javap</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/31/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（31）DispatcherServlet的逻辑处理">Spring源码分析（31）DispatcherServlet的逻辑处理</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="杂项 "
           href="/blog/2020/study/java/netease/2020%E4%BD%9C%E4%B8%9A/"
           data-tag="编程,java,杂项"
           data-author="" >
            <span class="post-title" title="作业记录">作业记录</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="杂项 "
           href="/blog/2020/study/java/netease/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/"
           data-tag="编程,java,读书,jvm"
           data-author="" >
            <span class="post-title" title="深入理解虚拟机-作业">深入理解虚拟机-作业</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 SpringCloud "
           href="/blog/2020/study/java/springcloud/springBoot/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="SpringBoot">SpringBoot</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 SpringCloud "
           href="/blog/2020/study/java/springcloud/springCloud/"
           data-tag="编程,java,框架"
           data-author="" >
            <span class="post-title" title="SpringCloud">SpringCloud</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="java 阅读 "
           href="/blog/2020/study/java/%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="JAVA性能优化权威">JAVA性能优化权威</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="java "
           href="/blog/2020/study/java/thread/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/"
           data-tag="编程,java,面试,线程"
           data-author="" >
            <span class="post-title" title="一次简单的线程池面试">一次简单的线程池面试</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="java "
           href="/blog/2020/study/java/%E4%BC%98%E5%8C%96/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
           data-tag="编程,设计模式"
           data-author="" >
            <span class="post-title" title="设计模式">设计模式</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="工具 "
           href="/blog/2020/study/java/%E5%B7%A5%E5%85%B7/maven/"
           data-tag="工具,编程"
           data-author="" >
            <span class="post-title" title="Maven">Maven</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 进阶a "
           href="/blog/2020/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/01.awk/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="1.AWK">1.AWK</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 进阶 "
           href="/blog/2020/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/02.%E5%91%A8%E6%9C%9F%E6%80%A7%E9%97%AE%E9%A2%98%E5%AE%9E%E9%AA%8C/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="2.MySQL周期性波动试验">2.MySQL周期性波动试验</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 进阶 "
           href="/blog/2020/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/03.%E5%AF%B9%E4%BA%8E%E4%B8%8D%E8%A7%84%E5%88%99%E7%9A%84%E5%BB%B6%E8%BF%9F%E7%8E%B0%E8%B1%A1%E7%9A%84%E8%A7%82%E5%AF%9F/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="3.对于不规则的延迟现象的观察">3.对于不规则的延迟现象的观察</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 进阶 "
           href="/blog/2020/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/04.%E5%88%97%E7%9A%84%E9%80%89%E6%8B%A9/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="4.选择原则">4.选择原则</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/06.%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="6.聚簇索引与非聚簇索引">6.聚簇索引与非聚簇索引</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 进阶 "
           href="/blog/2020/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/05.%E5%A4%9A%E5%88%97%E7%B4%A2%E5%BC%95/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="5.索引的优化--生效规则">5.索引的优化--生效规则</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 "
           href="/blog/2020/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/07.%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96/"
           data-tag="编程,数据库"
           data-author="" >
            <span class="post-title" title="7.索引覆盖">7.索引覆盖</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 进阶 "
           href="/blog/2020/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/08.%E7%B4%A2%E5%BC%95%E9%95%BF%E5%BA%A6/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="8.索引长度与区分度">8.索引长度与区分度</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 进阶 "
           href="/blog/2020/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/09.%E5%BB%B6%E8%BF%9F%E5%85%B3%E8%81%94/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="9.延迟关联">9.延迟关联</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 进阶 "
           href="/blog/2020/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/11.%E9%87%8D%E5%A4%8D%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%86%97%E4%BD%99%E7%B4%A2%E5%BC%95/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="11.重复索引与冗余索引">11.重复索引与冗余索引</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 进阶 "
           href="/blog/2020/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/10.%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%8E%92%E5%BA%8F/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="10.索引与排序">10.索引与排序</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 进阶 "
           href="/blog/2020/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/12.%E7%B4%A2%E5%BC%95%E7%A2%8E%E7%89%87%E4%BF%AE%E5%A4%8D/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="12.索引碎片与维护">12.索引碎片与维护</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 进阶 "
           href="/blog/2020/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/14.%E5%AD%90%E6%9F%A5%E8%AF%A2/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="14.子查询">14.子查询</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 进阶 "
           href="/blog/2020/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/13.explain/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="13.explain分析sql效果">13.explain分析sql效果</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 进阶 "
           href="/blog/2020/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/15.%E6%8A%80%E5%B7%A7/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="15.奇技淫巧">15.奇技淫巧</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 进阶 "
           href="/blog/2020/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/16.%E5%8F%98%E9%87%8F/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="16.变量的使用">16.变量的使用</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 进阶 "
           href="/blog/2020/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/17.%E4%BA%8B%E5%8A%A1/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="17.事务">17.事务</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="数据库 进阶 "
           href="/blog/2020/study/mysql/%E4%BC%98%E5%8C%96-%E7%87%95%E5%8D%81%E5%85%AB/18.%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"
           data-tag="编程,数据库,mysql"
           data-author="" >
            <span class="post-title" title="18.读写分离">18.读写分离</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/16/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（16）准备创建bean">Spring源码分析（16）准备创建bean</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/18/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（18）创建bean">Spring源码分析（18）创建bean</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
        <a  class="框架 spring "
           href="/blog/2020/study/java/cnblogSpring/07/"
           data-tag="编程,java,框架,spring"
           data-author="" >
            <span class="post-title" title="Spring源码分析（07）bean标签的解析及注册">Spring源码分析（07）bean标签的解析及注册</span>
            <!--隐藏时间-->
            <!--<span class="post-date" title="2020-04-21 15:16:48">2020/04/21</span>-->
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-study/java/cnblogSpring/31" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Spring源码分析（31）DispatcherServlet的逻辑处理</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
                <a  data-rel="框架">框架</a>/
            
                <a  data-rel="spring">spring</a>
            
        </span>
        
        
        <span class="tag">
            
            <a class="color3">编程</a>
            
            <a class="color5">java</a>
            
            <a class="color3">框架</a>
            
            <a class="color2">spring</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        <!--暂时影藏时间-->
        <!---->
        <!--创建时间:<time class="date" title='更新时间: 2020-04-21 12:33:31'>2020-04-21 15:16</time>-->
        <!---->
    </div>
    <div class="article-meta">
        
        <span>字数:6.4k</span>
        
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#MultipartContent类型的Request处理"><span class="toc-text">MultipartContent类型的Request处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#根据request信息寻找对应的Handler"><span class="toc-text">根据request信息寻找对应的Handler</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-根据request查找对应的Handler"><span class="toc-text">1.根据request查找对应的Handler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-加入拦截器到执行链"><span class="toc-text">2.加入拦截器到执行链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#没找到对应的Handler的错误处理"><span class="toc-text">没找到对应的Handler的错误处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#据当前Handler找对应的HandlerAdapter"><span class="toc-text">据当前Handler找对应的HandlerAdapter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缓存处理"><span class="toc-text">缓存处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Handlerlnterceptor的处理"><span class="toc-text">Handlerlnterceptor的处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#逻辑处理"><span class="toc-text">逻辑处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常视图的处理"><span class="toc-text">异常视图的处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#根据视图跳转页面"><span class="toc-text">根据视图跳转页面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-解析视图名称"><span class="toc-text">1.解析视图名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-页面跳转"><span class="toc-text">2.页面跳转</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>摘要: 本文结合《Spring源码深度解析》来分析Spring 5.0.6版本的源代码。若有描述错误之处，欢迎指正。</p>
</blockquote>
<p>据之前的示例，我们知道在HttpServlet类中分别提供了相应的服务方法，它们是doDelete()、doGet()、doOptions()、doPost()、doPut()和doTrace()，它会根据请求的不同形式将程序引导至对应的函数进行处理。这几个函数中最常用的函数无非就是doGet()和doPost()，那么我们就直接查看DispatcherServlet中对于这两个函数的逻辑实现。</p>
<pre><code class="java">    @Override
    protected final void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        processRequest(request, response);
    }

    @Override
    protected final void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        processRequest(request, response);
    }</code></pre>
<p>对于不同的方法，Spring并没有做特殊处理，而是统一将程序再一次地引导至processRequest(request,response)中。</p>
<pre><code class="java">    protected final void processRequest(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        // 记录当期时间，用于计算web请求的处理时间
        long startTime = System.currentTimeMillis();
        Throwable failureCause = null;

        LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();
        LocaleContext localeContext = buildLocaleContext(request);

        RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();
        ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);

        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
        asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());

        initContextHolders(request, localeContext, requestAttributes);

        try {
            doService(request, response);
        }
        catch (ServletException | IOException ex) {
            failureCause = ex;
            throw ex;
        }
        catch (Throwable ex) {
            failureCause = ex;
            throw new NestedServletException(&quot;Request processing failed&quot;, ex);
        }

        finally {
            resetContextHolders(request, previousLocaleContext, previousAttributes);
            if (requestAttributes != null) {
                requestAttributes.requestCompleted();
            }

            if (logger.isDebugEnabled()) {
                if (failureCause != null) {
                    this.logger.debug(&quot;Could not complete request&quot;, failureCause);
                }
                else {
                    if (asyncManager.isConcurrentHandlingStarted()) {
                        logger.debug(&quot;Leaving response open for concurrent processing&quot;);
                    }
                    else {
                        this.logger.debug(&quot;Successfully completed request&quot;);
                    }
                }
            }

            publishRequestHandledEvent(request, response, startTime, failureCause);
        }
    }</code></pre>
<p>函数中已经开始了对请求的处理虽然把细节转移到了doService函数中实现，但是我们不难看出处理请求前后所做的准备与处理工作。</p>
<ul>
<li><p>1.了保证当前线程的LocaleContext以及RequestAttributes可以在当前请求后能恢复，提取前线程的两个属性。</p>
</li>
<li><p>2.根据当前request创建对应的LocaleContext和RequestAttributes，并绑定到当前线程。</p>
</li>
<li><p>3.托给doService方法进一步处理。</p>
</li>
<li><p>4.请求处理结束后恢复线程到原始状态。</p>
</li>
<li><p>5.请求处理结束后无论成功与否发布事件通知。</p>
</li>
</ul>
<p>继续查看doService方法。</p>
<pre><code class="java">    protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {
        if (logger.isDebugEnabled()) {
            String resumed = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult() ? &quot; resumed&quot; : &quot;&quot;;
            logger.debug(&quot;DispatcherServlet with name &#39;&quot; + getServletName() + &quot;&#39;&quot; + resumed +
                    &quot; processing &quot; + request.getMethod() + &quot; request for [&quot; + getRequestUri(request) + &quot;]&quot;);
        }

        // Keep a snapshot of the request attributes in case of an include,
        // to be able to restore the original attributes after the include.
        Map&lt;String, Object&gt; attributesSnapshot = null;
        if (WebUtils.isIncludeRequest(request)) {
            attributesSnapshot = new HashMap&lt;&gt;();
            Enumeration&lt;?&gt; attrNames = request.getAttributeNames();
            while (attrNames.hasMoreElements()) {
                String attrName = (String) attrNames.nextElement();
                if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {
                    attributesSnapshot.put(attrName, request.getAttribute(attrName));
                }
            }
        }

        // Make framework objects available to handlers and view objects.
        request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());
        request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);
        request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);
        request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());

        if (this.flashMapManager != null) {
            FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);
            if (inputFlashMap != null) {
                request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));
            }
            request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());
            request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);
        }

        try {
            doDispatch(request, response);
        }
        finally {
            if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
                // Restore the original attribute snapshot, in case of an include.
                if (attributesSnapshot != null) {
                    restoreAttributesAfterInclude(request, attributesSnapshot);
                }
            }
        }
    }</code></pre>
<p>我们猜想对请求处理至少应该包括一些诸如寻找Handler并页面跳转之类的逻辑处理，但是，在doService中我们并没有看到想看到的逻辑，相反同样是一些准备工，但是这些准备工作却是必不可少的。Spring将经初始化的功能辅助工具变量，比如localeResolver,themeResolver等设置在request属性中，而这些属性会在接下来的处理中派上用场。</p>
<p>经过层层的准备工作，终于在doDispatch函数中到了完整的请求处理过程。</p>
<pre><code class="java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
        HttpServletRequest processedRequest = request;
        HandlerExecutionChain mappedHandler = null;
        boolean multipartRequestParsed = false;

        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

        try {
            ModelAndView mv = null;
            Exception dispatchException = null;

            try {
                // 如果是MultipartContent类型的request则转换request为MultipartHttpServletRequest类型的request
                processedRequest = checkMultipart(request);
                multipartRequestParsed = (processedRequest != request);

                // 根据request信息寻找对应的Handler
                // Determine handler for the current request.
                mappedHandler = getHandler(processedRequest);
                if (mappedHandler == null) {
                    // 如果没有找到对应的handler则通过response反馈错误信息
                    noHandlerFound(processedRequest, response);
                    return;
                }

                // 根据当前handler寻找对应的handlerAdapter
                // Determine handler adapter for the current request.
                HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

                // 如果当前handler支持last-modified头处理
                // Process last-modified header, if supported by the handler.
                String method = request.getMethod();
                boolean isGet = &quot;GET&quot;.equals(method);
                if (isGet || &quot;HEAD&quot;.equals(method)) {
                    long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                    if (logger.isDebugEnabled()) {
                        logger.debug(&quot;Last-Modified value for [&quot; + getRequestUri(request) + &quot;] is: &quot; + lastModified);
                    }
                    if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) {
                        return;
                    }
                }

                if (!mappedHandler.applyPreHandle(processedRequest, response)) {
                    return;
                }

                // Actually invoke the handler.
                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

                if (asyncManager.isConcurrentHandlingStarted()) {
                    return;
                }

                  // 试图转换处理 跟踪代码--&gt;1
                applyDefaultViewName(processedRequest, mv);
                // 拦截器postHandle处理 跟踪代码--&gt;2
                mappedHandler.applyPostHandle(processedRequest, response, mv);
            }
            catch (Exception ex) {
                dispatchException = ex;
            }
            catch (Throwable err) {
                // As of 4.3, we&#39;re processing Errors thrown from handler methods as well,
                // making them available for @ExceptionHandler methods and other scenarios.
                dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err);
            }
            // 结果处理 跟踪代码--&gt;3
            processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
        }
        catch (Exception ex) {
            // 异常处理
            triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
        }
        catch (Throwable err) {
            triggerAfterCompletion(processedRequest, response, mappedHandler,
                    new NestedServletException(&quot;Handler processing failed&quot;, err));
        }
        finally {
            if (asyncManager.isConcurrentHandlingStarted()) {
                // Instead of postHandle and afterCompletion
                if (mappedHandler != null) {
                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
                }
            }
            else {
                // Clean up any resources used by a multipart request.
                if (multipartRequestParsed) {
                    cleanupMultipart(processedRequest);
                }
            }
        }
    }



    // 跟踪代码&gt;&gt;1
    private void applyDefaultViewName(HttpServletRequest request, @Nullable ModelAndView mv) throws Exception {
        if (mv != null &amp;&amp; !mv.hasView()) {
            String defaultViewName = getDefaultViewName(request);
            if (defaultViewName != null) {
                mv.setViewName(defaultViewName);
            }
        }
    }
    // 跟踪代码&gt;&gt;2
    void applyPostHandle(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv)
            throws Exception {

        HandlerInterceptor[] interceptors = getInterceptors();
        if (!ObjectUtils.isEmpty(interceptors)) {
            for (int i = interceptors.length - 1; i &gt;= 0; i--) {
                HandlerInterceptor interceptor = interceptors[i];
                interceptor.postHandle(request, response, this.handler, mv);
            }
        }
    }

    // 跟踪代码&gt;&gt;3
    private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
            @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,
            @Nullable Exception exception) throws Exception {

        boolean errorView = false;

        if (exception != null) {
            if (exception instanceof ModelAndViewDefiningException) {
                logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception);
                mv = ((ModelAndViewDefiningException) exception).getModelAndView();
            }
            else {
                Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);
                mv = processHandlerException(request, response, handler, exception);
                errorView = (mv != null);
            }
        }

        // 如果handler示例中返回了view，则进行页面处理
        // Did the handler return a view to render?
        if (mv != null &amp;&amp; !mv.wasCleared()) {
            // 处理页面跳转
            render(mv, request, response);
            if (errorView) {
                WebUtils.clearErrorRequestAttributes(request);
            }
        }
        else {
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Null ModelAndView returned to DispatcherServlet with name &#39;&quot; + getServletName() +
                        &quot;&#39;: assuming HandlerAdapter completed request handling&quot;);
            }
        }

        if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
            // Concurrent handling started during a forward
            return;
        }

        if (mappedHandler != null) {
            mappedHandler.triggerAfterCompletion(request, response, null);
        }
    }
</code></pre>
<p>doDispatch函数中展示了Spring请求处理所涉及的主要逻辑，而我们之前设置在request中的各种辅助属性也都有被派上了用场。下面回顾一下逻辑处理的全过程。</p>
<h2 id="MultipartContent类型的Request处理"><a href="#MultipartContent类型的Request处理" class="headerlink" title="MultipartContent类型的Request处理"></a>MultipartContent类型的Request处理</h2><p>对于请求的处理，Spring首先考虑的对于Multipart的处理，如果是MultipartContent类型的request，则转换request为MultipartHttpServletRequest类型的request。</p>
<pre><code class="java">    protected HttpServletRequest checkMultipart(HttpServletRequest request) throws MultipartException {
        if (this.multipartResolver != null &amp;&amp; this.multipartResolver.isMultipart(request)) {
            if (WebUtils.getNativeRequest(request, MultipartHttpServletRequest.class) != null) {
                logger.debug(&quot;Request is already a MultipartHttpServletRequest - if not in a forward, &quot; +
                        &quot;this typically results from an additional MultipartFilter in web.xml&quot;);
            }
            else if (hasMultipartException(request)) {
                logger.debug(&quot;Multipart resolution previously failed for current request - &quot; +
                        &quot;skipping re-resolution for undisturbed error rendering&quot;);
            }
            else {
                try {
                    return this.multipartResolver.resolveMultipart(request);
                }
                catch (MultipartException ex) {
                    if (request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) != null) {
                        logger.debug(&quot;Multipart resolution failed for error dispatch&quot;, ex);
                        // Keep processing error dispatch with regular request handle below
                    }
                    else {
                        throw ex;
                    }
                }
            }
        }
        // If not returned before: return original request.
        return request;
    }</code></pre>
<h2 id="根据request信息寻找对应的Handler"><a href="#根据request信息寻找对应的Handler" class="headerlink" title="根据request信息寻找对应的Handler"></a>根据request信息寻找对应的Handler</h2><p>在Spring中最简单的映射处理器配置如下：</p>
<pre><code class="xml">    &lt;bean id=&quot;simpleUrlMapping&quot; class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;
        &lt;property name=&quot;mappings&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;/userlist.htm&quot;&gt;userController&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;</code></pre>
<p>在Spring加载的过程中，Spring会将类型为SimpleUrlHandlerMapping的实例加载到this.handlerMappings中，按照常理推断，根据request提取对应的Handler，无非就是提取当前实例中的userController但是userController为继承自AbstractController类型实例，与HandlerExecutionChain并无任何关联，那么这一步是如何封装的呢？</p>
<pre><code class="java">    protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
        if (this.handlerMappings != null) {
            for (HandlerMapping hm : this.handlerMappings) {
                if (logger.isTraceEnabled()) {
                    logger.trace(
                            &quot;Testing handler map [&quot; + hm + &quot;] in DispatcherServlet with name &#39;&quot; + getServletName() + &quot;&#39;&quot;);
                }
                HandlerExecutionChain handler = hm.getHandler(request);
                if (handler != null) {
                    return handler;
                }
            }
        }
        return null;
    }</code></pre>
<p>在之前的内容我们提过，在系统启动时Spring会将所有的映射类型的bean注到this.handlerMappings变量中，所以函数的目的就是遍历所有的HandlerMapping，并调用其getHandler方法进行封装处理。以SimpleUrlHandlerMapping为例查看其getHandler方法如下：</p>
<pre><code class="java">    public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
        Object handler = getHandlerInternal(request);
        if (handler == null) {
            handler = getDefaultHandler();
        }
        if (handler == null) {
            return null;
        }
        // Bean name or resolved handler?
        if (handler instanceof String) {
            String handlerName = (String) handler;
            handler = obtainApplicationContext().getBean(handlerName);
        }

        HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);
        if (CorsUtils.isCorsRequest(request)) {
            CorsConfiguration globalConfig = this.globalCorsConfigSource.getCorsConfiguration(request);
            CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);
            CorsConfiguration config = (globalConfig != null ? globalConfig.combine(handlerConfig) : handlerConfig);
            executionChain = getCorsHandlerExecutionChain(request, executionChain, config);
        }
        return executionChain;
    }</code></pre>
<p>函数中首先会使用getHandlerlntemal方法根据request信息获取对应的Handler，如果以SimpleUrlHandlerMapping为分析，那么我们推断此步骤提供的功能很可能就是根据RL找到匹配的Controller并返回，当然如果没有找到对应的Controller处理器那么程序会尝试去查找配置中的默认处理器，当然，当查找的controller为S时ng类型时，那就意味着返回的是配置的bean名称，要根bean名称查找对应的bean，最后，还要通过getHandlerExecutionChain方法对返回的Handler进行封装，以保证满足返回类型的配。下面详细分析这个过程。</p>
<h3 id="1-根据request查找对应的Handler"><a href="#1-根据request查找对应的Handler" class="headerlink" title="1.根据request查找对应的Handler"></a>1.根据request查找对应的Handler</h3><p>首先从根据request查找对应的Handler开始分析。</p>
<pre><code class="java">    protected Object getHandlerInternal(HttpServletRequest request) throws Exception {
        // 截取用于匹配url有效路径
        String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);
        // 跟踪代码--&gt;1
        // 根据路径寻找handler
        Object handler = lookupHandler(lookupPath, request);
        if (handler == null) {
            // We need to care for the default handler directly, since we need to
            // expose the PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE for it as well.
            Object rawHandler = null;
            if (&quot;/&quot;.equals(lookupPath)) {
                // 如果请求路径仅是“/”用Roothandler处理
                rawHandler = getRootHandler();
            }
            if (rawHandler == null) {
                // 无法找到handler则用默认handler
                rawHandler = getDefaultHandler();
            }
            if (rawHandler != null) {
                // Bean name or resolved handler?
                // 根据beanName获取对应bean
                if (rawHandler instanceof String) {
                    String handlerName = (String) rawHandler;
                    rawHandler = obtainApplicationContext().getBean(handlerName);
                }
                // 模版方法
                validateHandler(rawHandler, request);
                handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, null);
            }
        }
        if (handler != null &amp;&amp; logger.isDebugEnabled()) {
            logger.debug(&quot;Mapping [&quot; + lookupPath + &quot;] to &quot; + handler);
        }
        else if (handler == null &amp;&amp; logger.isTraceEnabled()) {
            logger.trace(&quot;No handler mapping found for [&quot; + lookupPath + &quot;]&quot;);
        }
        return handler;
    }
    // 跟踪代码&gt;&gt;1
    protected Object lookupHandler(String urlPath, HttpServletRequest request) throws Exception {
        // 直接匹配情况的处理
        // Direct match?
        Object handler = this.handlerMap.get(urlPath);
        if (handler != null) {
            // Bean name or resolved handler?
            if (handler instanceof String) {
                String handlerName = (String) handler;
                handler = obtainApplicationContext().getBean(handlerName);
            }
            validateHandler(handler, request);
            return buildPathExposingHandler(handler, urlPath, urlPath, null);
        }

        // 通配符匹配的处理
        // Pattern match?
        List&lt;String&gt; matchingPatterns = new ArrayList&lt;&gt;();
        for (String registeredPattern : this.handlerMap.keySet()) {
            if (getPathMatcher().match(registeredPattern, urlPath)) {
                matchingPatterns.add(registeredPattern);
            }
            else if (useTrailingSlashMatch()) {
                if (!registeredPattern.endsWith(&quot;/&quot;) &amp;&amp; getPathMatcher().match(registeredPattern + &quot;/&quot;, urlPath)) {
                    matchingPatterns.add(registeredPattern + &quot;/&quot;);
                }
            }
        }

        String bestMatch = null;
        Comparator&lt;String&gt; patternComparator = getPathMatcher().getPatternComparator(urlPath);
        if (!matchingPatterns.isEmpty()) {
            matchingPatterns.sort(patternComparator);
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Matching patterns for request [&quot; + urlPath + &quot;] are &quot; + matchingPatterns);
            }
            bestMatch = matchingPatterns.get(0);
        }
        if (bestMatch != null) {
            handler = this.handlerMap.get(bestMatch);
            if (handler == null) {
                if (bestMatch.endsWith(&quot;/&quot;)) {
                    handler = this.handlerMap.get(bestMatch.substring(0, bestMatch.length() - 1));
                }
                if (handler == null) {
                    throw new IllegalStateException(
                            &quot;Could not find handler for best pattern match [&quot; + bestMatch + &quot;]&quot;);
                }
            }
            // Bean name or resolved handler?
            if (handler instanceof String) {
                String handlerName = (String) handler;
                handler = obtainApplicationContext().getBean(handlerName);
            }
            // 模版方法
            validateHandler(handler, request);
            String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestMatch, urlPath);

            // There might be multiple &#39;best patterns&#39;, let&#39;s make sure we have the correct URI template variables
            // for all of them
            Map&lt;String, String&gt; uriTemplateVariables = new LinkedHashMap&lt;&gt;();
            for (String matchingPattern : matchingPatterns) {
                if (patternComparator.compare(bestMatch, matchingPattern) == 0) {
                    Map&lt;String, String&gt; vars = getPathMatcher().extractUriTemplateVariables(matchingPattern, urlPath);
                    Map&lt;String, String&gt; decodedVars = getUrlPathHelper().decodePathVariables(request, vars);
                    uriTemplateVariables.putAll(decodedVars);
                }
            }
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;URI Template variables for request [&quot; + urlPath + &quot;] are &quot; + uriTemplateVariables);
            }
            return buildPathExposingHandler(handler, bestMatch, pathWithinMapping, uriTemplateVariables);
        }

        // No handler found...
        return null;
    }</code></pre>
<p>根据URL获取对应Handler的匹配规则代码实现起来虽然很长，但是并不难理解，考虑了直接匹配与通配符两种情况。其中要提及的是buildPathExposingHandler函数，它将Handler封装成了HandlerExecutionChain类型。</p>
<pre><code class="java">    protected Object buildPathExposingHandler(Object rawHandler, String bestMatchingPattern,
            String pathWithinMapping, @Nullable Map&lt;String, String&gt; uriTemplateVariables) {

        HandlerExecutionChain chain = new HandlerExecutionChain(rawHandler);
        chain.addInterceptor(new PathExposingHandlerInterceptor(bestMatchingPattern, pathWithinMapping));
        if (!CollectionUtils.isEmpty(uriTemplateVariables)) {
            chain.addInterceptor(new UriTemplateVariablesHandlerInterceptor(uriTemplateVariables));
        }
        return chain;
    }</code></pre>
<p>在函数中我们看到了通过将Handler参数形式传入，井构建HandlerExecutionChain类型实例，加入了两个拦截器。此时我们似乎已经了解了Spring样大番周折的目的。链处理机制，是Spring中非常常用的处理方式，是AOP中的重要组成部分，可以方便地对目标对象进行扩展及拦截，这是常优秀的设计。</p>
<h3 id="2-加入拦截器到执行链"><a href="#2-加入拦截器到执行链" class="headerlink" title="2.加入拦截器到执行链"></a>2.加入拦截器到执行链</h3><p>getHandlerExecutionChain函数最主要的目的是将配置中的对应拦截器加入到执行链中，以保证这些拦截器可以有效地作用于目标对象。</p>
<pre><code class="java">    protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {
        HandlerExecutionChain chain = (handler instanceof HandlerExecutionChain ?
                (HandlerExecutionChain) handler : new HandlerExecutionChain(handler));

        String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);
        for (HandlerInterceptor interceptor : this.adaptedInterceptors) {
            if (interceptor instanceof MappedInterceptor) {
                MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;
                if (mappedInterceptor.matches(lookupPath, this.pathMatcher)) {
                    chain.addInterceptor(mappedInterceptor.getInterceptor());
                }
            }
            else {
                chain.addInterceptor(interceptor);
            }
        }
        return chain;
    }</code></pre>
<h2 id="没找到对应的Handler的错误处理"><a href="#没找到对应的Handler的错误处理" class="headerlink" title="没找到对应的Handler的错误处理"></a>没找到对应的Handler的错误处理</h2><p>每个请求都应该对应着－Handler，因为每个请求都会在后台有相应的逻辑对应，而逻辑的现就是在Handler中，所以一旦遇到没有找到Handler的情况（正常情况如果没有URL匹配的Handler，开发人员可以设置默认的Handler来处理求，但是如果默认请求也未设置就会出现Handler为空的情况），就只能通过respons向用户返回错误信息。</p>
<pre><code class="java">    protected void noHandlerFound(HttpServletRequest request, HttpServletResponse response) throws Exception {
        if (pageNotFoundLogger.isWarnEnabled()) {
            pageNotFoundLogger.warn(&quot;No mapping found for HTTP request with URI [&quot; + getRequestUri(request) +
                    &quot;] in DispatcherServlet with name &#39;&quot; + getServletName() + &quot;&#39;&quot;);
        }
        if (this.throwExceptionIfNoHandlerFound) {
            throw new NoHandlerFoundException(request.getMethod(), getRequestUri(request),
                    new ServletServerHttpRequest(request).getHeaders());
        }
        else {
            response.sendError(HttpServletResponse.SC_NOT_FOUND);
        }
    }</code></pre>
<h2 id="据当前Handler找对应的HandlerAdapter"><a href="#据当前Handler找对应的HandlerAdapter" class="headerlink" title="据当前Handler找对应的HandlerAdapter"></a>据当前Handler找对应的HandlerAdapter</h2><p>在WebApplicationContext的初始化过程中我们讨论了HandlerAdapters的初始化，了解了在默认情况下普通的Web请求会交给SimpleControllerHandlerAdapter去处理下面我们以SimpleControllerHandlerAdapter为例来分析获取适配器的逻辑。</p>
<pre><code class="java">    protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {
        if (this.handlerAdapters != null) {
            for (HandlerAdapter ha : this.handlerAdapters) {
                if (logger.isTraceEnabled()) {
                    logger.trace(&quot;Testing handler adapter [&quot; + ha + &quot;]&quot;);
                }
                if (ha.supports(handler)) {
                    return ha;
                }
            }
        }
        throw new ServletException(&quot;No adapter for handler [&quot; + handler +
                &quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;);
    }</code></pre>
<p>通过上面的函数我们了解到，对于获取适配器的逻辑无非就是遍历所有适配器来选择合适的适配器并返回它，而某个适配器是否适用于当前的Handler逻辑被封装在具体的适配器中。进一步查看SimpleContro11erHandlerAdapter中的supports方法。</p>
<pre><code class="java">    public boolean supports(Object handler) {
        return (handler instanceof Controller);
    }</code></pre>
<p>分析到这里，一切已经明了，SimpleControlierHandlerAdapter就是用于处理普的Web请求的，而且对于SpringMVC来说，我们会把逻辑封装至Controller的子类中，例如我们之前的引导示例UserController就是继承自AbstractController，而AbstractController实现Controller接口。</p>
<h2 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h2><p>在研究Spring对缓存处理的功能支持前，我们先了解一个概念：Last-Modified缓存机制。</p>
<p>1.在客户端第一次输入URL时，服务器端会返回内容和状态码200，表示请求成功，同时会添加一个“Last-Modified”的响应头，表示此文件在服务器上的最后更新时间，例如，“Last-Modified:Wed，14 Mar 2012 10:22:42 GMT”表示最后更新时间为（2012-03-14 10:22）。</p>
<p>2.客户端第二次请求此URL时，客户端会向服务器发送请求头“If-Modified-Since”，询问服务器该时间之后当前请求内容是否有被修改过，如“If-Modified-Since:Wed,14 Mar 2012 10:22:42 GMT”，如果服务器端的内容没有变化，则动返回HTTP 304状态码（只要响应头，内容为空，这样就节省了网络带宽）。</p>
<p>Spring提供的对Last-Modified机制的支持，只需要实现LastModified接口，如下所示：</p>
<pre><code class="java">public class HelloWorldLastModifiedCacheController extends AbstractController implements LastModified {

    private long lastModified;

    @Override
    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception {
        response.getWriter().write(&quot;&lt;a href=&#39;&#39;&gt;this&lt;/a&gt;&quot;);
        return null;
    }

    @Override
    public long getLastModified(HttpServletRequest request) {
        if (lastModified == 0L) {
            // 第一次或者逻辑有变化的时候，应该重新返回内容最新修改的时间戳
            lastModified = System.currentTimeMillis();
        }
        return lastModified;
    }
}</code></pre>
<p>HelloWorldLastModifiedCacheController只需要实现LastModified接的getLastModified方法，保证当内容发生改变时返回最新修改时间即可。</p>
<p>Spring判断是否过期，通过判断请求的“If-Modified-Since”是否大于等于当前的getLastModified方法的时间戳，如果是，则认为没有修改。上面的controller与普通的controller并无太大别，声明如下：</p>
<pre><code class="xml">&lt;bean name=&quot;/hellLastModified&quot; class=&quot;HelloWorldLastModifiedCacheController&quot; /&gt;</code></pre>
<h2 id="Handlerlnterceptor的处理"><a href="#Handlerlnterceptor的处理" class="headerlink" title="Handlerlnterceptor的处理"></a>Handlerlnterceptor的处理</h2><p>ServletAPI定义的servlet过滤器可以在servlet处理每个Web请求的前后分别对它进行前置处理和后处理。此外，有些时候，你可能只想处理由某些SpringMVC处理程序处理的Web请求，并在些处理程序返回的模型属性被传递到视图前对它们进行一些操作。</p>
<p>SpringMVC允许你通过处理拦截eb请求，进行前置处理和后置理。处理拦截是在Spring的Web应用程序上下文中配置的，因此它们可以利用各种容器特性，并引用容器中声明的任何bean。处理拦截是针对特殊的处理程序映射进行注册的，因此它只拦截通过这些处理程序映射的请求。每个处理拦截都必须实现HandlerInterceptor接口，它包含三个需要你实现的回调方法：preHandle()、postHandle()和afterCompletion()。第一个和第二个方法分别是在处理程序处理请求之前和之后被调用的。第二个方法还允许访问返回的ModelAndView对象，因此可以在它里面操作模型属性。最后一个方法是在所有请求处理完成之后被用的（如视图呈现之后），以下是HandlerInterceptor的简单实现：</p>
<pre><code class="java">public class MyTestInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        long startTime = System.currentTimeMillis();
        request.setAttribute(&quot;startTime&quot;, startTime);
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        long startTime = (Long) request.getAttribute(&quot;startTime&quot;);
        request.removeAttribute(&quot;startTime&quot;);
        long endTime = System.currentTimeMillis();
        modelAndView.addObject(&quot;handlingTime&quot;, endTime - startTime);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {

    }
}</code></pre>
<p>这个拦截器的preHandler()方法中，你记录了起始时间，并将它保存到请求属性中。这个方法应该返回true，允许DispatcherServlet继续处理请求。否则，DispatcherServlet会认为这个方法已经处理了请求，直接将响应返回给用户。然后，在postHandler()方法中，从请求属性中加载起始时间，并将它与当前时间进行比较。你可以计算总的续时间，然后这个时间添加到模型中，传递给视图。最后，afterCompletion()法无事可做，空着就可以了。</p>
<h2 id="逻辑处理"><a href="#逻辑处理" class="headerlink" title="逻辑处理"></a>逻辑处理</h2><p>于逻辑处理其实是通过适配器中转调用Hndler并返回视图的，对应代码如下：</p>
<pre><code class="java">mv=ha.handle(processedRequest,response,mappedHandler.getHandler());</code></pre>
<p>同样还是以引导示例为基础进行处理逻辑分析，之前分析过，对于都普通的Web请求，Spring默认使用SirnpleControllerHandlerAdapter类进行处理，我们进入SimpleControllerHandlerAdapter类的handle方法如下：</p>
<pre><code class="java">    public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)
            throws Exception {

        return ((Controller) handler).handleRequest(request, response);
    }</code></pre>
<p>但是回顾引导示例中的UserController，我们的逻辑是写在handleRequestinternal函数中而不是handlerRequest函数，所以我们还需要进一步分析这期间所包含的处理流程。</p>
<pre><code class="java">    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response)
            throws Exception {

        if (HttpMethod.OPTIONS.matches(request.getMethod())) {
            response.setHeader(&quot;Allow&quot;, getAllowHeader());
            return null;
        }

        // Delegate to WebContentGenerator for checking and preparing.
        checkRequest(request);
        prepareResponse(response);

        // 如果需要session内的同步执行
        // Execute handleRequestInternal in synchronized block if required.
        if (this.synchronizeOnSession) {
            HttpSession session = request.getSession(false);
            if (session != null) {
                Object mutex = WebUtils.getSessionMutex(session);
                synchronized (mutex) {
                    // 调用用户的逻辑
                    return handleRequestInternal(request, response);
                }
            }
        }
        // 调用用户逻辑
        return handleRequestInternal(request, response);
    }</code></pre>
<h2 id="异常视图的处理"><a href="#异常视图的处理" class="headerlink" title="异常视图的处理"></a>异常视图的处理</h2><p>有时候系统运行过程中出现异常，而我们并不希望就此中断对用户的服务，而是至少告知客户当前系统在处理逻辑的过程中出现了异常，甚至告知他们因为什么原因导致的。Spring中的异常处理机制会帮我们完成这个工作。其实，这里Spring主要的工作就是将逻辑引导至HandlerExceptionResolver类的resolveException方法，而HandlerExceptionResolver的使用，我在讲解WebApplicationContext的初始化的时候已经介绍过了。</p>
<pre><code class="java">    protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,
            @Nullable Object handler, Exception ex) throws Exception {

        // Check registered HandlerExceptionResolvers...
        ModelAndView exMv = null;
        if (this.handlerExceptionResolvers != null) {
            for (HandlerExceptionResolver handlerExceptionResolver : this.handlerExceptionResolvers) {
                exMv = handlerExceptionResolver.resolveException(request, response, handler, ex);
                if (exMv != null) {
                    break;
                }
            }
        }
        if (exMv != null) {
            if (exMv.isEmpty()) {
                request.setAttribute(EXCEPTION_ATTRIBUTE, ex);
                return null;
            }
            // We might still need view name translation for a plain error model...
            if (!exMv.hasView()) {
                String defaultViewName = getDefaultViewName(request);
                if (defaultViewName != null) {
                    exMv.setViewName(defaultViewName);
                }
            }
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Handler execution resulted in exception - forwarding to resolved error view: &quot; + exMv, ex);
            }
            WebUtils.exposeErrorRequestAttributes(request, ex, getServletName());
            return exMv;
        }

        throw ex;
    }</code></pre>
<h2 id="根据视图跳转页面"><a href="#根据视图跳转页面" class="headerlink" title="根据视图跳转页面"></a>根据视图跳转页面</h2><p>无论是一个系统还是一个站点，最重要的工作都是与用户进行交互，用户操作系统后无论下发的命令成功与否都需要给用户一个反馈，以便于用户进行下一步的判断。所以，在逻辑处的最后一定会涉及一个页面跳转的问题。</p>
<pre><code class="java">protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception {
        // Determine locale for request and apply it to the response.
        Locale locale =
                (this.localeResolver != null ? this.localeResolver.resolveLocale(request) : request.getLocale());
        response.setLocale(locale);

        View view;
        String viewName = mv.getViewName();
        if (viewName != null) {
            // We need to resolve the view name.
            view = resolveViewName(viewName, mv.getModelInternal(), locale, request);
            if (view == null) {
                throw new ServletException(&quot;Could not resolve view with name &#39;&quot; + mv.getViewName() +
                        &quot;&#39; in servlet with name &#39;&quot; + getServletName() + &quot;&#39;&quot;);
            }
        }
        else {
            // No need to lookup: the ModelAndView object contains the actual View object.
            view = mv.getView();
            if (view == null) {
                throw new ServletException(&quot;ModelAndView [&quot; + mv + &quot;] neither contains a view name nor a &quot; +
                        &quot;View object in servlet with name &#39;&quot; + getServletName() + &quot;&#39;&quot;);
            }
        }

        // Delegate to the View object for rendering.
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Rendering view [&quot; + view + &quot;] in DispatcherServlet with name &#39;&quot; + getServletName() + &quot;&#39;&quot;);
        }
        try {
            if (mv.getStatus() != null) {
                response.setStatus(mv.getStatus().value());
            }
            view.render(mv.getModelInternal(), request, response);
        }
        catch (Exception ex) {
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Error rendering view [&quot; + view + &quot;] in DispatcherServlet with name &#39;&quot; +
                        getServletName() + &quot;&#39;&quot;, ex);
            }
            throw ex;
        }
    }</code></pre>
<h3 id="1-解析视图名称"><a href="#1-解析视图名称" class="headerlink" title="1.解析视图名称"></a>1.解析视图名称</h3><p>在上文中我们提DispatcherServlet会根据ModelAndView选择合适的视图来进行渲染，而这一功能就是在resolveViewName函数中完成的。</p>
<pre><code class="java">    protected View resolveViewName(String viewName, @Nullable Map&lt;String, Object&gt; model,
            Locale locale, HttpServletRequest request) throws Exception {

        if (this.viewResolvers != null) {
            for (ViewResolver viewResolver : this.viewResolvers) {
                View view = viewResolver.resolveViewName(viewName, locale);
                if (view != null) {
                    return view;
                }
            }
        }
        return null;
    }</code></pre>
<p>我们以org.Spring仕amework.web.serlet.view.InternalResourceViewResolver为例来分析ViewResolver逻辑解析过程，其中resolveViewName函数的实现是在其父类AbstractCachingViewResolver中完成的。</p>
<pre><code class="java">    public View resolveViewName(String viewName, Locale locale) throws Exception {
        if (!isCache()) {
            // 不存在缓存的情况下直接创建视图
            return createView(viewName, locale);
        }
        else {
            // 直接从缓存中提取
            Object cacheKey = getCacheKey(viewName, locale);
            View view = this.viewAccessCache.get(cacheKey);
            if (view == null) {
                synchronized (this.viewCreationCache) {
                    view = this.viewCreationCache.get(cacheKey);
                    if (view == null) {
                        // Ask the subclass to create the View object.
                        view = createView(viewName, locale);
                        if (view == null &amp;&amp; this.cacheUnresolved) {
                            view = UNRESOLVED_VIEW;
                        }
                        if (view != null) {
                            this.viewAccessCache.put(cacheKey, view);
                            this.viewCreationCache.put(cacheKey, view);
                            if (logger.isTraceEnabled()) {
                                logger.trace(&quot;Cached view [&quot; + cacheKey + &quot;]&quot;);
                            }
                        }
                    }
                }
            }
            return (view != UNRESOLVED_VIEW ? view : null);
        }
    }</code></pre>
<p>在父类UrlBasedViewResolver中重写了createView函数。</p>
<pre><code class="java">    protected View createView(String viewName, Locale locale) throws Exception {
        // 如果当前解析器不支持前解析器viewName为空等情况
        // If this resolver is not supposed to handle the given view,
        // return null to pass on to the next resolver in the chain.
        if (!canHandle(viewName, locale)) {
            return null;
        }

        // 处理前缀为redirect:xx 的情况
        // Check for special &quot;redirect:&quot; prefix.
        // String REDIRECT_URL_PREFIX = &quot;redirect:&quot;;
        if (viewName.startsWith(REDIRECT_URL_PREFIX)) {
            String redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length());
            RedirectView view = new RedirectView(redirectUrl,
                    isRedirectContextRelative(), isRedirectHttp10Compatible());
            String[] hosts = getRedirectHosts();
            if (hosts != null) {
                view.setHosts(hosts);
            }
            return applyLifecycleMethods(REDIRECT_URL_PREFIX, view);
        }

        // 处理前缀为forward:xx 的情况
        // Check for special &quot;forward:&quot; prefix. 
        // String FORWARD_URL_PREFIX = &quot;forward:&quot;;
        if (viewName.startsWith(FORWARD_URL_PREFIX)) {
            String forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length());
            return new InternalResourceView(forwardUrl);
        }

        // 跟踪代码--&gt;1
        // Else fall back to superclass implementation: calling loadView.
        return super.createView(viewName, locale);
    }

    // 跟踪代码&gt;&gt;1
    protected View createView(String viewName, Locale locale) throws Exception {
        // 跟踪代码--&gt;2
        return loadView(viewName, locale);
    }
    // 跟踪代码&gt;&gt;2
    protected View loadView(String viewName, Locale locale) throws Exception {
        // 跟踪代码--&gt;3
        AbstractUrlBasedView view = buildView(viewName);
        View result = applyLifecycleMethods(viewName, view);
        return (view.checkResource(locale) ? result : null);
    }

    // 跟踪代码&gt;&gt;3
    protected AbstractUrlBasedView buildView(String viewName) throws Exception {
        Class&lt;?&gt; viewClass = getViewClass();
        Assert.state(viewClass != null, &quot;No view class&quot;);

        AbstractUrlBasedView view = (AbstractUrlBasedView) BeanUtils.instantiateClass(viewClass);
        // 添加前端以及后缀
        view.setUrl(getPrefix() + viewName + getSuffix());

        String contentType = getContentType();
        if (contentType != null) {
            // 设置congtentType
            view.setContentType(contentType);
        }

        view.setRequestContextAttribute(getRequestContextAttribute());
        view.setAttributesMap(getAttributesMap());

        Boolean exposePathVariables = getExposePathVariables();
        if (exposePathVariables != null) {
            view.setExposePathVariables(exposePathVariables);
        }
        Boolean exposeContextBeansAsAttributes = getExposeContextBeansAsAttributes();
        if (exposeContextBeansAsAttributes != null) {
            view.setExposeContextBeansAsAttributes(exposeContextBeansAsAttributes);
        }
        String[] exposedContextBeanNames = getExposedContextBeanNames();
        if (exposedContextBeanNames != null) {
            view.setExposedContextBeanNames(exposedContextBeanNames);
        }

        return view;
    }</code></pre>
<p>通读以上代码，我们发现对于InternalResourceViewResolver所提供的解析功能主要考虑到了几个方面的处理。</p>
<ul>
<li>基于效率的考虑，提供了缓存的支持。</li>
<li>提供了对redirect:xx和forward:xx前缀的支持。</li>
<li>添加了前缀及后缀，并向View中加入了必需的属性设置。</li>
</ul>
<h3 id="2-页面跳转"><a href="#2-页面跳转" class="headerlink" title="2.页面跳转"></a>2.页面跳转</h3><p>当通过viewName解析到对应的View后，就可以进一步地处理跳转逻辑了。</p>
<pre><code class="java">    public void render(@Nullable Map&lt;String, ?&gt; model, HttpServletRequest request,
            HttpServletResponse response) throws Exception {

        if (logger.isTraceEnabled()) {
            logger.trace(&quot;Rendering view with name &#39;&quot; + this.beanName + &quot;&#39; with model &quot; + model +
                &quot; and static attributes &quot; + this.staticAttributes);
        }

        Map&lt;String, Object&gt; mergedModel = createMergedOutputModel(model, request, response);
        prepareResponse(request, response);
        renderMergedOutputModel(mergedModel, getRequestToExpose(request), response);
    }</code></pre>
<p>在引导示例中，我们了解到对于ModelView的使用，可以将一些属性直接放入其中，然后在页面上直接通过JSTL语法或者原始的request获取。这是一个很方便也很神奇的功能，但是实现却并不复杂，无非是把我们将要用到的属性放入request中，以便在其他地方可以直接调用，而解析这些属性的工作就是在createMergedOutputModel数中完成的。</p>
<pre><code class="java">    protected Map&lt;String, Object&gt; createMergedOutputModel(@Nullable Map&lt;String, ?&gt; model,
            HttpServletRequest request, HttpServletResponse response) {

        @SuppressWarnings(&quot;unchecked&quot;)
        Map&lt;String, Object&gt; pathVars = (this.exposePathVariables ?
                (Map&lt;String, Object&gt;) request.getAttribute(View.PATH_VARIABLES) : null);

        // Consolidate static and dynamic model attributes.
        int size = this.staticAttributes.size();
        size += (model != null ? model.size() : 0);
        size += (pathVars != null ? pathVars.size() : 0);

        Map&lt;String, Object&gt; mergedModel = new LinkedHashMap&lt;&gt;(size);
        mergedModel.putAll(this.staticAttributes);
        if (pathVars != null) {
            mergedModel.putAll(pathVars);
        }
        if (model != null) {
            mergedModel.putAll(model);
        }

        // Expose RequestContext?
        if (this.requestContextAttribute != null) {
            mergedModel.put(this.requestContextAttribute, createRequestContext(request, response, mergedModel));
        }

        return mergedModel;
    }</code></pre>
<pre><code class="java">    protected void renderMergedOutputModel(
            Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception {

        // 将model数据以属性方式设置到request中
        // Expose the model object as request attributes.
        exposeModelAsRequestAttributes(model, request);

        // Expose helpers as request attributes, if any.
        exposeHelpers(request);

        // Determine the path for the request dispatcher.
        String dispatcherPath = prepareForRendering(request, response);

        // Obtain a RequestDispatcher for the target resource (typically a JSP).
        RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath);
        if (rd == null) {
            throw new ServletException(&quot;Could not get RequestDispatcher for [&quot; + getUrl() +
                    &quot;]: Check that the corresponding file exists within your web application archive!&quot;);
        }

        // If already included or response already committed, perform include, else forward.
        if (useInclude(request, response)) {
            response.setContentType(getContentType());
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Including resource [&quot; + getUrl() + &quot;] in InternalResourceView &#39;&quot; + getBeanName() + &quot;&#39;&quot;);
            }
            rd.include(request, response);
        }

        else {
            // Note: The forwarded resource is supposed to determine the content type itself.
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Forwarding to resource [&quot; + getUrl() + &quot;] in InternalResourceView &#39;&quot; + getBeanName() + &quot;&#39;&quot;);
            }
            rd.forward(request, response);
        }
    }</code></pre>

      
       
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>


<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>Spring源码分析（31）DispatcherServlet的逻辑处理</p>
    <p><span class="copy-title">文章字数:</span><span class="post-count">6.4k</span></p>
    <p><span class="copy-title">本文作者:</span><a  title="莫问-廖远佩">莫问-廖远佩</a></p>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> 内容非商用，仅作为学习记录之用若有侵权请联系：liaoyuanpei@foxmail.com。
    </p>
</div>








    </div>
    <div class="copyright">
        <p class="footer-entry">©2020 莫问-廖远佩</p>

<!--<p class="footer-entry">-->
    <!--<a _ngcontent-c1="" href="https://www.upyun.com/" target="_blank" rel="noopener" style="display: inline-block; opacity: .55">-->
        <!--<img _ngcontent-c1="" alt="upyun logo" src="/blog/img/upanyun_logo2.png" style="width:55px;height:24px">-->
        <!--又拍云提供加速-->
    <!--</a>-->
<!--</p>-->
<p class="footer-entry">
    <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61092402000103" target="_blank"><img src="https://img.alicdn.com/tfs/TB1..50QpXXXXX7XpXXXXXXXXXX-40-40.png">陕公安备案61092402000103号</a>
</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" ></a>

    </div>
</div>
<div class="acParent"></div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>如果喜欢就打赏一下,鼓励下呗!</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/blog/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/blog/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/blog/js/jquery.pjax.js?v=1.0.1" ></script>

<script src="/blog/js/script.js?v=1.0.1" ></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#生活','#技巧','#工具','#编程','#devops','#docker','#理财','#方法论','#win10','#java','#框架','#spring','#linux','#算法','#正则','#登天梯','#中间件','#mybatis','#面试','#数据库','#mysql','#redis','#python','#读书','#思维导图','#目录','#git','#ide','#程序','#前端','#js','#vue','#jvm','#GC','#杂项','#线程','#设计模式',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0px;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
        .nav .hide-list.fullscreen {
            left: 492px
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("/blog/img/blog_bg.png");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
    .post .pjax article :not(pre) > code {
        color: #24292e;
        font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
        background-color: rgba(27,31,35,.05);
        border-radius: 3px;
        font-size: 85%;
        margin: 0;
        padding: .2em .4em;
    }
    
</style>







</html>
